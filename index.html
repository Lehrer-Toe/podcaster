<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Podcast Aufnahme</title>

  <!-- JSZip & FileSaver für „Alles herunterladen" -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <!-- Supabase von CDN direkt einbinden -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    /* --- Allgemeine Styles --- */
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #f4f4f4;
      color: #333;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }
    
    /* --- Header --- */
    header {
      background: #4CAF50;
      color: #fff;
      padding: 1.5rem;
      text-align: center;
      box-shadow: 0 2px 15px rgba(0,0,0,0.1);
      position: relative;
    }
    
    .version {
      position: absolute;
      right: 10px;
      top: 10px;
      font-size: 0.8rem;
      opacity: 0.8;
    }
    
    /* --- Container --- */
    .container {
      max-width: 700px;
      margin: 2rem auto;
      background: #fff;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.06);
    }
    
    @media (max-width: 768px) {
      .container {
        margin: 1rem;
        padding: 1.5rem;
      }
    }
    
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
      font-weight: 600;
    }
    
    h2 {
      font-size: 1.4rem;
      margin-bottom: 1rem;
      color: #4caf50;
    }
    
    /* --- Aufnahme-Controls --- */
    .record-controls {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      margin-bottom: 1.5rem;
    }
    
    .filename-input-container {
      position: relative;
      margin-bottom: 0.5rem;
    }
    
    input[type="text"], input[type="password"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      transition: all 0.2s ease;
      -webkit-appearance: none;
      appearance: none;
    }
    
    input[type="text"]:focus, input[type="password"]:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
    }
    
    .input-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #555;
    }
    
    /* --- Button Styles --- */
    button {
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      color: #fff;
      transition: all 0.2s ease;
      -webkit-appearance: none;
      appearance: none;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 48px; /* Für bessere Touch-Ziele auf iPads */
    }
    
    button:active:not(:disabled) {
      transform: translateY(1px);
    }
    
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    button:focus {
      outline: none;
    }
    
    /* --- Button-Zeilen --- */
    .button-row {
      display: flex;
      gap: 0.8rem;
    }
    
    .button-row button {
      flex: 1;
    }
    
    /* --- Spezielle Button-Typen --- */
    #startBtn {
      background: #4CAF50;
    }
    
    #stopBtn {
      background: #f44336;
    }
    
    #pauseBtn, #resumeBtn {
      background: #ff9800;
    }
    
    #uploadBtn {
      background: #673AB7;
    }
    
    #clearStorageBtn {
      background: #607D8B;
    }
    
    /* --- Audio Format Info --- */
    .format-info {
      background-color: #f0f8e6;
      border-radius: 8px;
      padding: 10px 15px;
      margin-bottom: 1rem;
      border-left: 4px solid #8bc34a;
    }
    
    /* --- Status-Anzeigen --- */
    .status-bar {
      display: flex;
      align-items: center;
      margin-bottom: 1rem;
      padding: 0.5rem 0;
      min-height: 2rem;
    }
    
    #timerDisplay {
      text-align: center;
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      color: #4caf50;
    }
    
    /* --- Audio Player --- */
    audio {
      width: 100%;
      margin: 1.5rem 0;
      border-radius: 8px;
    }
    
    #uploadStatus {
      margin: 1rem 0;
      font-weight: 500;
      padding: 0.75rem;
      border-radius: 8px;
      background: #f5f5f5;
      min-height: 3rem;
      display: flex;
      align-items: center;
    }
    
    /* --- Visualizer --- */
    .visualizer-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 20px auto 40px auto;
      border-radius: 50%;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
      border: 1px solid #f0f0f0;
    }
    
    .visualizer-circle {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #f44336;
      border-radius: 50%;
      transition: width 0.1s, height 0.1s;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    }
    
    /* --- Tabs --- */
    .tab-container {
      margin-top: 2.5rem;
    }
    
    .tab-buttons {
      display: flex;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 1.5rem;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .tab-button {
      background: #f0f0f0;
      border: none;
      padding: 0.75rem 1.5rem;
      margin-right: 0.5rem;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      color: #666;
      font-weight: 500;
      min-width: auto;
    }
    
    .tab-button.active {
      background: #4CAF50;
      color: white;
    }
    
    .tab-content {
      display: none;
      padding: 1rem 0;
    }
    
    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* --- Dateien-Liste --- */
    .file-list, .admin-panel {
      margin-top: 1rem;
    }
    
    .file-list h2, .admin-panel h2 {
      margin-bottom: 1rem;
      color: #4caf50;
    }
    
    .file-list ul, .admin-panel ul {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }
    
    .file-list li, .admin-panel li {
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 8px;
      background: #f8f9fa;
      transition: all 0.2s ease;
    }
    
    .file-list a, .admin-panel a {
      color: #4CAF50;
      text-decoration: none;
      flex: 1;
      padding: 0.25rem 0;
    }
    
    .file-list a:hover, .admin-panel a:hover {
      text-decoration: underline;
    }
    
    /* --- Admin Panel --- */
    .admin-panel {
      display: none;
      border-top: 1px solid #e0e0e0;
      padding-top: 1.5rem;
      margin-top: 2rem;
    }
    
    .admin-panel button.delete {
      background: #f44336;
      padding: 0.5rem 0.75rem;
      margin-left: 0.75rem;
      font-size: 0.9rem;
    }
    
    .admin-panel button.toggle-visibility {
      background: #2196F3;
      padding: 0.5rem 0.75rem;
      margin-left: 0.5rem;
      font-size: 0.9rem;
    }
    
    .admin-controls {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    #adminLoginBtn {
      background: #424242;
      margin-top: 2rem;
    }
    
    #closeAdminBtn {
      background: #424242;
    }
    
    /* --- Indikatoren und Animationen --- */
    .recording-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f44336;
      margin-right: 8px;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    
    .status-icon {
      margin-right: 5px;
    }
    
    .error-message {
      color: #f44336;
      font-weight: 500;
    }
    
    .success-message {
      color: #4CAF50;
      font-weight: 500;
    }
    
    .file-size {
      color: #888;
      margin-left: 0.75rem;
      font-size: 0.9rem;
    }
    
    .file-visibility {
      display: flex;
      align-items: center;
      margin-left: 0.5rem;
    }
    
    .file-visibility-icon {
      margin-right: 0.25rem;
    }
    
    .public-file {
      background-color: #f1f8e9;
    }
    
    .private-file {
      background-color: #f8f9fa;
    }
    
    /* --- Password Modal --- */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    
    .modal-content {
      background-color: #fff;
      margin: 15% auto;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
      max-width: 400px;
      width: 90%;
    }
    
    .modal-title {
      margin-top: 0;
      color: #4caf50;
    }
    
    .modal-footer {
      margin-top: 1.5rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.8rem;
    }
    
    /* iPad-spezifische Styles */
    @media (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2), 
           (max-width: 1024px) and (min-resolution: 192dpi) {
      button, input, select {
        font-size: 1.1rem;
        padding: 0.85rem 1rem;
      }
      
      h1 {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Podcast Aufnahme</h1>
    <div class="version">v2.2</div>
  </header>

  <div class="container">
    <!-- Aufnahme-Steuerung -->
    <div class="record-controls">
      <div class="filename-input-container">
        <label for="filename" class="input-label">Dateiname (Pflicht)</label>
        <input type="text" id="filename" placeholder="Bitte Dateinamen eingeben" />
      </div>

      <!-- Audio-Format Info -->
      <div class="format-info" id="formatInfo">
        Aktuelles Format: <span id="currentFormat">Wird ermittelt...</span>
      </div>

      <!-- Erste Zeile mit Start und Stopp Buttons -->
      <div class="button-row">
        <button id="startBtn">Aufnahme starten</button>
        <button id="stopBtn" disabled>Stoppen</button>
      </div>
      
      <!-- Zweite Zeile mit Pause und Fortsetzen Buttons -->
      <div class="button-row">
        <button id="pauseBtn" disabled>Pausieren</button>
        <button id="resumeBtn" disabled>Fortsetzen</button>
      </div>
      
      <!-- Dritte Zeile mit Upload Button -->
      <button id="uploadBtn" disabled>Hochladen</button>
      
      <!-- Vierte Zeile mit Speicher löschen Button -->
      <button id="clearStorageBtn">Lokalen Speicher löschen</button>
    </div>

    <!-- Status-Anzeige -->
    <div class="status-bar">
      <span id="recordingStatus"></span>
    </div>

    <!-- Timer-Anzeige -->
    <div id="timerDisplay">00:00</div>

    <!-- Visueller Lautstärke-Indikator -->
    <div class="visualizer-container">
      <div class="visualizer-circle" id="visualizerCircle"></div>
    </div>

    <!-- Audio-Vorschau & Status -->
    <audio id="audioPlayer" controls></audio>
    <p id="uploadStatus"></p>

    <!-- Tab-Navigation -->
    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="recordings">Aufnahmen</button>
        <button class="tab-button" data-tab="help">Hilfe</button>
      </div>
      
      <!-- Aufnahmen Tab -->
      <div class="tab-content active" id="recordings-tab">
        <!-- Öffentliche Dateiliste -->
        <div class="file-list">
          <h2>Vorhandene Aufnahmen</h2>
          <ul id="fileList"></ul>
        </div>
      </div>
      
      <!-- Hilfe Tab -->
      <div class="tab-content" id="help-tab">
        <h2>Verwendung</h2>
        <ol>
          <li>Geben Sie einen Dateinamen ein</li>
          <li>Klicken Sie auf "Aufnahme starten"</li>
          <li>Sie können die Aufnahme pausieren und fortsetzen</li>
          <li>Nach dem Stoppen können Sie die Aufnahme anhören</li>
          <li>Klicken Sie auf "Hochladen", um die Aufnahme zu speichern</li>
        </ol>
        <p><strong>Hinweis:</strong> Ihr Browser speichert die letzte Aufnahme lokal. Sie können den lokalen Speicher mit dem "Lokalen Speicher löschen"-Button leeren.</p>
        
        <h3>Fehlerbehebung</h3>
        <ul>
          <li><strong>Mikrofon funktioniert nicht:</strong> Prüfen Sie die Browsereinstellungen und erteilen Sie die Berechtigung für den Mikrofonzugriff.</li>
          <li><strong>Aufnahme startet nicht:</strong> Stellen Sie sicher, dass ein Dateiname eingegeben wurde.</li>
          <li><strong>Probleme auf iOS:</strong> Starten Sie Safari neu oder verwenden Sie den Privatmodus, falls Sie Probleme haben.</li>
          <li><strong>Hochladen funktioniert nicht:</strong> Möglicherweise ist die Verbindung zum Server unterbrochen. Versuchen Sie es später erneut.</li>
        </ul>
      </div>
    </div>

    <!-- Admin-Oberfläche -->
    <div class="admin-panel" id="adminPanel">
      <h2>Admin-Oberfläche</h2>
      
      <div class="admin-controls">
        <button id="downloadAllBtn" style="background: #795548;">Alles herunterladen</button>
        <button id="refreshAdminBtn" style="background: #009688;">Aktualisieren</button>
      </div>
      
      <p>Hinweis: Klicken Sie auf den "Öffentlich/Privat"-Button, um die Sichtbarkeit einer Datei zu ändern.</p>
      
      <ul id="adminFileList"></ul>
      <button id="closeAdminBtn">Admin schließen</button>
    </div>

    <!-- Admin-Login Button -->
    <button id="adminLoginBtn">Admin Login</button>
  </div>

  <!-- Password Modal -->
  <div id="passwordModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title">Admin Login</h3>
      <p>Bitte geben Sie das Admin-Passwort ein:</p>
      <input type="password" id="adminPasswordInput" placeholder="Passwort">
      <div class="modal-footer">
        <button id="cancelLoginBtn" style="background-color: #f44336;">Abbrechen</button>
        <button id="confirmLoginBtn" style="background-color: #4CAF50;">Anmelden</button>
      </div>
    </div>
  </div>

  <!-- Regular JavaScript statt ES Module -->
  <script>
    // --- 1) SUPABASE KONFIG --- 
    const SUPABASE_URL = "https://qzmzlrsfuepbkqwzbrir.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6bXpscnNmdWVwYmtxd3picmlyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE5NTkxMzAsImV4cCI6MjA1NzUzNTEzMH0.zLZDSfylloUxlxYPEpfO4VMAdf0cNpUzKH2T9qv8ezI";
    
    // Initialisiere Supabase Client - nur EINMAL für die gesamte App
    let supabaseClient;
    try {
      // Erstelle den Client mit deaktiviertem Caching und Auth
      const options = {
        db: {
          schema: 'public'
        },
        auth: {
          autoRefreshToken: false,
          persistSession: false,
          detectSessionInUrl: false
        },
        global: {
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        }
      };
      
      // Erstelle den Client nur einmal
      supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, options);
      console.log("Supabase Client erfolgreich initialisiert");
    } catch (err) {
      console.error("Fehler bei der Supabase-Initialisierung:", err);
      showError("Verbindungsfehler: Bitte später erneut versuchen.");
    }
    
    // Funktion zum Aktualisieren der Dateilisten
    function refreshFileList() {
      // Cache leeren
      clearLocalCache();
      
      // Dateilisten neu laden ohne neuen Client zu erstellen
      loadFiles();
      
      // Admin-Dateien neu laden, falls im Admin-Bereich
      if (appSettings.adminLoggedIn) {
        loadAdminFiles();
      }
    }

    // --- 2) Variablen ---
    let mediaRecorder;
    let audioStream;
    let audioChunks = [];
    let currentRecordingBlob = null;
    let audioContext, analyser, dataArray, animationId;
    let recordingTime = 0;
    let recordingInterval = null;
    let isPaused = false;
    let isRecording = false;
    
    // Eigene Uploads speichern
    let myUploads = [];
    
    // Dateisichtbarkeit im lokalen Speicher verwalten
    let publicFiles = [];
    
    // Geräte- und Format-Erkennung
    const appSettings = {
      adminLoggedIn: false,
      lastFileName: localStorage.getItem('lastFileName') || '',
      isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && navigator.maxTouchPoints > 0,
      isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
      bestAudioFormat: 'audio/mp4', // Standard-Fallback für iOS
      myUploads: JSON.parse(localStorage.getItem('myUploads') || '[]'),
      publicFiles: JSON.parse(localStorage.getItem('publicFiles') || '[]')
    };
    
    // Lade Uploads und öffentliche Dateien aus localStorage
    myUploads = appSettings.myUploads;
    publicFiles = appSettings.publicFiles;

    // --- 3) DOM-Elemente ---
    const filenameInput    = document.getElementById("filename");
    const startBtn         = document.getElementById("startBtn");
    const pauseBtn         = document.getElementById("pauseBtn");
    const resumeBtn        = document.getElementById("resumeBtn");
    const stopBtn          = document.getElementById("stopBtn");
    const uploadBtn        = document.getElementById("uploadBtn");
    const clearStorageBtn  = document.getElementById("clearStorageBtn");
    const audioPlayer      = document.getElementById("audioPlayer");
    const uploadStatus     = document.getElementById("uploadStatus");
    const fileList         = document.getElementById("fileList");
    const adminPanel       = document.getElementById("adminPanel");
    const adminFileList    = document.getElementById("adminFileList");
    const adminLoginBtn    = document.getElementById("adminLoginBtn");
    const closeAdminBtn    = document.getElementById("closeAdminBtn");
    const refreshAdminBtn  = document.getElementById("refreshAdminBtn");
    const visualizerCircle = document.getElementById("visualizerCircle");
    const downloadAllBtn   = document.getElementById("downloadAllBtn");
    const timerDisplay     = document.getElementById("timerDisplay");
    const recordingStatus  = document.getElementById("recordingStatus");
    const formatInfo       = document.getElementById("formatInfo");
    const currentFormat    = document.getElementById("currentFormat");
    const tabButtons       = document.querySelectorAll(".tab-button");
    const tabContents      = document.querySelectorAll(".tab-content");
    
    // Password Modal Elemente
    const passwordModal     = document.getElementById("passwordModal");
    const adminPasswordInput = document.getElementById("adminPasswordInput");
    const confirmLoginBtn   = document.getElementById("confirmLoginBtn");
    const cancelLoginBtn    = document.getElementById("cancelLoginBtn");

    // Funktion zum Laden der Dateien über direkte REST-API
    function loadFilesByREST() {
      fileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      // Cache-Busting Parameter hinzufügen
      const cacheBuster = Date.now();
      const url = `${SUPABASE_URL}/storage/v1/object/list/podcast-audio`;
      
      fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache'
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP-Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        const files = data || [];
        
        if (!files || files.length === 0) {
          fileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
          return;
        }
        
        fileList.innerHTML = "";
        
        // Zur Anzeige ausgewählte Dateien
        const visibleFiles = files.filter(function(file) {
          // Dateien anzeigen, die dem Benutzer gehören ODER öffentlich sind
          const userOwnsFile = myUploads.includes(file.name);
          const isPublic = isFilePublic(file.name);
          
          return userOwnsFile || isPublic;
        });
        
        if (visibleFiles.length === 0) {
          fileList.innerHTML = "<li>Keine sichtbaren Aufnahmen vorhanden</li>";
          return;
        }
        
        // Liste erstellen
        for (const file of visibleFiles) {
          const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/podcast-audio/${encodeURIComponent(file.name)}`;
          
          // Cache-Busting Parameter zum URL hinzufügen
          const noCacheUrl = publicUrl + (publicUrl.includes('?') ? '&' : '?') + '_cb=' + cacheBuster;
          
          const isPublic = isFilePublic(file.name);
          const isOwner = myUploads.includes(file.name);
          
          const li = document.createElement('li');
          if (isPublic) {
            li.className = 'public-file';
          }
          
          li.innerHTML = `
            <a href="${noCacheUrl}" target="_blank" download="${file.name}">
              ${file.name}
            </a>
            <span class="file-size">(${formatBytes(file.metadata?.size || 0)})</span>
            ${isPublic ? '<span class="file-visibility-icon">👁️</span>' : ''}
            ${isOwner ? ' (Meine Datei)' : ''}
          `;
          
          fileList.appendChild(li);
        }
      })
      .catch(function(err) {
        console.error("Fehler beim Laden der Dateien:", err);
        fileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien</li>";
      });
    }

    // Funktion zum Laden der Admin-Dateien über direkte REST-API
    function loadAdminFilesByREST() {
      adminFileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      // Cache-Busting Parameter hinzufügen
      const cacheBuster = Date.now();
      const url = `${SUPABASE_URL}/storage/v1/object/list/podcast-audio`;
      
      fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache'
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP-Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        const files = data || [];
        
        if (!files || files.length === 0) {
          adminFileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
          return;
        }
        
        adminFileList.innerHTML = "";
        
        // Admin-Liste erstellen
        for (const file of files) {
          const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/podcast-audio/${encodeURIComponent(file.name)}`;
          
          // Cache-Busting Parameter zum URL hinzufügen
          const noCacheUrl = publicUrl + (publicUrl.includes('?') ? '&' : '?') + '_cb=' + cacheBuster;
          
          const isPublic = isFilePublic(file.name);
          
          const li = document.createElement('li');
          li.className = isPublic ? 'public-file' : 'private-file';
          li.dataset.filename = file.name;
          
          li.innerHTML = `
            <a href="${noCacheUrl}" target="_blank">${file.name}</a>
            <span class="file-size">(${formatBytes(file.metadata?.size || 0)})</span>
            <span class="file-visibility">
              <span class="file-visibility-icon">${isPublic ? '👁️' : '🔒'}</span>
            </span>
            <button class="toggle-visibility" data-filename="${file.name}">
              ${isPublic ? 'Privat machen' : 'Öffentlich machen'}
            </button>
            <button class="delete" data-filename="${file.name}">Löschen</button>
          `;
          
          adminFileList.appendChild(li);
        }
      })
      .catch(function(err) {
        console.error("Fehler beim Laden der Admin-Dateien:", err);
        adminFileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien</li>";
      });
    }

    // --- 4) Initialisierung ---
    function init() {
      // Debug-Info für bessere Fehlerbehebung
      console.log("Browser-Info:", navigator.userAgent);
      console.log("Geräteerkennung - iOS:", appSettings.isIOS, "Safari:", appSettings.isSafari);
      
      // Cache löschen beim Start
      clearLocalCache();
      
      // Lade gespeicherte Einstellungen aus dem LocalStorage
      if (appSettings.lastFileName) {
        filenameInput.value = appSettings.lastFileName;
      }
      
      // Immer validateFileName ausführen, um den Button-Status zu aktualisieren
      validateFileName();
      
      // Prüfe Browser-Unterstützung
      if (!checkBrowserSupport()) return;
      
      // Bestimme das beste Audio-Format für diesen Browser
      determineOptimalAudioFormat();
      
      // Setze Event Listeners
      setupEventListeners();
      
      // Prüfe, ob es eine gespeicherte Aufnahme gibt
      checkForSavedRecording();
      
      // Lade vorhandene Dateien mit direkter REST-API
      loadFilesByREST();
    }

    // --- Function: Cache löschen ---
    function clearLocalCache() {
      console.log("Lokalen Cache für Dateien löschen...");
      
      // Entferne Dateilisten-Cache
      sessionStorage.removeItem('fileListCache');
      
      // Entferne gespeicherte API-Antworten
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        if (key && key.startsWith('api_')) {
          sessionStorage.removeItem(key);
        }
      }
      
      console.log("Lokaler Cache gelöscht");
    }

    // --- 5) Browser-Unterstützung prüfen ---
    function checkBrowserSupport() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showError("Ihr Browser unterstützt keine Audioaufnahmen. Bitte verwenden Sie einen modernen Browser wie Chrome, Firefox oder Edge.");
        startBtn.disabled = true;
        return false;
      }
      return true;
    }
    
    // --- Datei-Sichtbarkeit verwalten (im localStorage) ---
    function setFilePublic(fileName, isPublic) {
      if (isPublic) {
        // Datei öffentlich machen
        if (!publicFiles.includes(fileName)) {
          publicFiles.push(fileName);
        }
      } else {
        // Datei privat machen
        publicFiles = publicFiles.filter(name => name !== fileName);
      }
      
      // Im localStorage speichern
      localStorage.setItem('publicFiles', JSON.stringify(publicFiles));
      appSettings.publicFiles = publicFiles;
      
      return true;
    }
    
    // --- Prüfe, ob eine Datei öffentlich ist ---
    function isFilePublic(fileName) {
      return publicFiles.includes(fileName);
    }
    
    // --- Beste Audio-Format-Erkennung ---
    function determineOptimalAudioFormat() {
      // Für iOS-Geräte werden wir diese Formate in dieser Reihenfolge testen
      const formatsToTest = [
        'audio/mp4',
        'audio/aac',
        'audio/wav',
        'audio/mpeg',
        'audio/webm;codecs=pcm',
        'audio/webm'
      ];
      
      let foundFormat = false;
      
      // Standardwert anzeigen während wir testen
      currentFormat.textContent = "Wird geprüft...";
      
      for (const format of formatsToTest) {
        if (MediaRecorder.isTypeSupported(format)) {
          console.log(`Format ${format} wird unterstützt!`);
          appSettings.bestAudioFormat = format;
          currentFormat.textContent = formatReadableName(format);
          foundFormat = true;
          break;
        } else {
          console.log(`Format ${format} wird nicht unterstützt.`);
        }
      }
      
      if (!foundFormat) {
        // Wenn kein getestetes Format unterstützt wird, verwenden wir den Standard-MediaRecorder ohne expliziten mimeType
        currentFormat.textContent = "Standard (geräteabhängig)";
        console.warn("Kein bekanntes Format wird unterstützt. Verwende Standard-Format des Browsers.");
        appSettings.bestAudioFormat = '';
      }
    }
    
    function formatReadableName(mimeType) {
      const formatMap = {
        'audio/mp4': 'MP4 Audio',
        'audio/aac': 'AAC Audio',
        'audio/wav': 'WAV Audio',
        'audio/mpeg': 'MP3 Audio',
        'audio/webm': 'WebM Audio',
        'audio/webm;codecs=pcm': 'WebM PCM Audio'
      };
      
      return formatMap[mimeType] || mimeType;
    }
    
    function getFileExtension(mimeType) {
      const extensionMap = {
        'audio/mp4': '.m4a',
        'audio/aac': '.aac',
        'audio/wav': '.wav',
        'audio/mpeg': '.mp3',
        'audio/webm': '.webm',
        'audio/webm;codecs=pcm': '.webm'
      };
      
      return extensionMap[mimeType] || '.m4a'; // Standardmäßig .m4a für iOS
    }

    // --- 6) Event Listeners ---
    function setupEventListeners() {
      // Dateiname-Validierung
      filenameInput.addEventListener("input", validateFileName);
      
      // Aufnahme-Steuerung
      startBtn.addEventListener("click", startRecording);
      pauseBtn.addEventListener("click", pauseRecording);
      resumeBtn.addEventListener("click", resumeRecording);
      stopBtn.addEventListener("click", stopRecording);
      uploadBtn.addEventListener("click", uploadRecording);
      clearStorageBtn.addEventListener("click", clearAllLocalStorage);
      
      // Admin-Bereich
      adminLoginBtn.addEventListener("click", showPasswordModal);
      closeAdminBtn.addEventListener("click", () => {
        adminPanel.style.display = "none";
        appSettings.adminLoggedIn = false;
      });
      downloadAllBtn.addEventListener("click", downloadAllFiles);
      refreshAdminBtn.addEventListener("click", loadAdminFiles);
      
      // Password Modal
      confirmLoginBtn.addEventListener("click", handleAdminLogin);
      cancelLoginBtn.addEventListener("click", hidePasswordModal);
      adminPasswordInput.addEventListener("keyup", (e) => {
        if (e.key === "Enter") {
          handleAdminLogin();
        }
      });
      
      // Tab-Navigation
      tabButtons.forEach(button => {
        button.addEventListener("click", () => {
          const tabId = button.dataset.tab;
          
          // Aktiven Tab wechseln
          tabButtons.forEach(btn => btn.classList.remove("active"));
          tabContents.forEach(content => content.classList.remove("active"));
          
          button.classList.add("active");
          document.getElementById(`${tabId}-tab`).classList.add("active");
        });
      });

      // Dateiliste Verwalten (für Admin)
      adminFileList.addEventListener("click", handleAdminFileAction);
      
      // Für iOS Touch-Events aktivieren
      if (appSettings.isIOS) {
        document.addEventListener('touchstart', function(){}, {passive: true});
      }
    }

    // --- 7) Dateiname-Validierung ---
    function validateFileName() {
      const filename = filenameInput.value.trim();
      
      if (filename) {
        startBtn.disabled = false;
        localStorage.setItem('lastFileName', filename);
      } else {
        startBtn.disabled = true;
      }

      // Debug-Information
      console.log("Dateiname validiert:", filename, "Start-Button aktiviert:", !startBtn.disabled);
    }
    
    // --- 7.1) Zeige Password Modal ---
    function showPasswordModal() {
      passwordModal.style.display = "block";
      adminPasswordInput.value = "";
      adminPasswordInput.focus();
    }
    
    // --- 7.2) Verstecke Password Modal ---
    function hidePasswordModal() {
      passwordModal.style.display = "none";
    }
    
    // Funktion zum Aktualisieren der Dateilisten
    // --- 7.3) Lokalen Speicher vollständig löschen ---
    function clearAllLocalStorage() {
      if (confirm("Möchten Sie wirklich den gesamten lokalen Speicher löschen? Dies entfernt alle gespeicherten Aufnahmen und Einstellungen.")) {
        // Speicher für aktuelle Aufnahme löschen
        clearSavedRecording();
        
        // Benutzereinstellungen löschen
        localStorage.removeItem('lastFileName');
        localStorage.removeItem('myUploads');
        localStorage.removeItem('publicFiles');
        
        // Session Storage leeren
        sessionStorage.clear();
        
        // Audio-Player zurücksetzen
        audioPlayer.src = '';
        
        // Variable zurücksetzen
        currentRecordingBlob = null;
        myUploads = [];
        publicFiles = [];
        appSettings.myUploads = [];
        appSettings.publicFiles = [];
        
        // UI aktualisieren
        uploadBtn.disabled = true;
        
        // Dateiliste aktualisieren
        loadFiles();
        
        showSuccess("Lokaler Speicher wurde vollständig gelöscht.");
      }
    }

    // --- 8) Aufnahme starten ---
    function startRecording() {
      const filename = filenameInput.value.trim();
      
      if (!filename) {
        showError("Bitte erst einen Dateinamen eingeben!");
        return;
      }
      
      if (!checkBrowserSupport()) return;
      
      // Spezielle Constraints für iOS
      const constraints = {
        audio: true
      };
      
      if (appSettings.isIOS) {
        // iOS benötigt manchmal explizite Einstellungen
        constraints.audio = {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        };
      }
      
      // Audiostream anfordern
      navigator.mediaDevices.getUserMedia(constraints)
        .then(function(stream) {
          audioStream = stream;
          
          // MediaRecorder initialisieren
          let recorderOptions = {};
          
          // Verwende das beste erkannte Format, wenn verfügbar
          if (appSettings.bestAudioFormat) {
            recorderOptions.mimeType = appSettings.bestAudioFormat;
            console.log(`Verwende Format: ${appSettings.bestAudioFormat}`);
          } else {
            console.log("Verwende Standard-Format des Browsers");
          }
          
          try {
            mediaRecorder = new MediaRecorder(audioStream, recorderOptions);
          } catch (formatError) {
            console.error("Format wird nicht unterstützt:", formatError);
            console.log("Versuche ohne mimeType-Angabe...");
            mediaRecorder = new MediaRecorder(audioStream);
            
            // Update formatInfo-Anzeige
            currentFormat.textContent = "Standard (geräteabhängig)";
          }
          
          // MediaRecorder-Format anzeigen
          if (mediaRecorder.mimeType) {
            currentFormat.textContent = formatReadableName(mediaRecorder.mimeType);
            console.log("Tatsächlich verwendetes Format:", mediaRecorder.mimeType);
            appSettings.bestAudioFormat = mediaRecorder.mimeType;
          }
          
          audioChunks = [];
          
          // Event Handling
          mediaRecorder.ondataavailable = handleDataAvailable;
          mediaRecorder.onstop = handleRecordingStop;
          mediaRecorder.onpause = handleRecordingPause;
          mediaRecorder.onresume = handleRecordingResume;
          mediaRecorder.onerror = function(event) {
            showError("Aufnahmefehler: " + event.error);
          };
          
          // Aufnahme starten
          mediaRecorder.start(100); // Chunks alle 100ms für bessere iOS-Kompatibilität
          isRecording = true;
          isPaused = false;
          
          // UI aktualisieren
          updateRecordingUI(true);
          
          // Visualizer und Timer starten
          startVisualizer(audioStream);
          startTimer();
          
          showMessage("Aufnahme läuft...", true);
        })
        .catch(function(err) {
          let errorMsg = "Aufnahmefehler";
          
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            errorMsg = "Mikrofon-Zugriff verweigert. Bitte erteilen Sie die Berechtigung in Ihren Browsereinstellungen.";
          } else if (err.name === 'NotFoundError') {
            errorMsg = "Kein Mikrofon gefunden. Bitte prüfen Sie, ob ein Mikrofon angeschlossen ist.";
          } else {
            errorMsg = err.message || "Aufnahmefehler. Bitte versuchen Sie es erneut.";
          }
          
          showError(errorMsg);
          console.error("Aufnahmefehler:", err);
        });
    }
    
    // --- 9) Aufnahme pausieren ---
    function pauseRecording() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        try {
          mediaRecorder.pause();
          isPaused = true;
          pauseTimer();
          pauseVisualizer();
          updateRecordingUI(true, true);
          showMessage("Aufnahme pausiert", false);
        } catch (error) {
          console.error("Fehler beim Pausieren:", error);
          // Wenn pausieren auf iOS fehlschlägt, bieten wir an, stattdessen zu stoppen
          if (appSettings.isIOS) {
            showWarning("Pausieren wird auf einigen iOS-Geräten nicht unterstützt. Bitte stoppen Sie die Aufnahme, wenn Sie fertig sind.");
          }
        }
      }
    }
    
    // --- 10) Aufnahme fortsetzen ---
    function resumeRecording() {
      if (mediaRecorder && mediaRecorder.state === "paused") {
        try {
          mediaRecorder.resume();
          isPaused = false;
          resumeTimer();
          resumeVisualizer();
          updateRecordingUI(true, false);
          showMessage("Aufnahme fortgesetzt", true);
        } catch (error) {
          console.error("Fehler beim Fortsetzen:", error);
          showWarning("Es gab ein Problem beim Fortsetzen der Aufnahme. Versuchen Sie, die Aufnahme zu stoppen und neu zu starten.");
        }
      }
    }

    // --- 11) Aufnahme stoppen ---
    function stopRecording() {
      if (mediaRecorder && (mediaRecorder.state === "recording" || mediaRecorder.state === "paused")) {
        try {
          mediaRecorder.stop();
          isRecording = false;
          isPaused = false;
          
          if (audioStream) {
            audioStream.getTracks().forEach(function(track) {
              track.stop();
            });
          }
          
          stopTimer();
          stopVisualizer();
          updateRecordingUI(false);
        } catch (error) {
          console.error("Fehler beim Stoppen der Aufnahme:", error);
          showError("Fehler beim Stoppen der Aufnahme. Bitte laden Sie die Seite neu.");
          
          // Notfall-Reset falls das Stoppen nicht funktioniert
          isRecording = false;
          isPaused = false;
          stopTimer();
          stopVisualizer();
          updateRecordingUI(false);
          
          if (audioStream) {
            audioStream.getTracks().forEach(function(track) {
              track.stop();
            });
          }
        }
      }
    }

    // --- 12) Media Recorder Event Handler ---
    function handleDataAvailable(event) {
      if (event.data && event.data.size > 0) {
        audioChunks.push(event.data);
        // Speichere den aktuellen Stand im LocalStorage
        saveRecordingChunks();
      }
    }
    
    function handleRecordingStop() {
      try {
        // Erstelle Blob aus gesammelten Daten
        const mimeType = appSettings.bestAudioFormat || 'audio/mp4';
        currentRecordingBlob = new Blob(audioChunks, { type: mimeType });
        
        // Audio-Player aktualisieren
        const audioUrl = URL.createObjectURL(currentRecordingBlob);
        audioPlayer.src = audioUrl;
        
        // UI aktualisieren
        uploadBtn.disabled = false;
        showMessage("Aufnahme bereit – bitte jetzt anhören und hochladen.", false);
        
        // Lokale Kopie speichern
        saveRecording(currentRecordingBlob, mimeType);
        
        console.log("Aufnahme erfolgreich gestoppt. Größe:", formatBytes(currentRecordingBlob.size), "Format:", mimeType);
      } catch (error) {
        console.error("Fehler beim Verarbeiten der Aufnahme:", error);
        showError("Fehler beim Verarbeiten der Aufnahme: " + error.message);
      }
    }
    
    function handleRecordingPause() {
      showMessage("Aufnahme pausiert", false);
    }
    
    function handleRecordingResume() {
      showMessage("Aufnahme fortgesetzt", true);
    }

    // --- 13) Aufnahme hochladen ---
    function uploadRecording() {
      if (!currentRecordingBlob) {
        showError("Keine Aufnahme vorhanden!");
        return;
      }
      
      showMessage("Wird hochgeladen...", false);
      uploadBtn.disabled = true;
      
      // Dateinamen vorbereiten
      let baseName = filenameInput.value.trim();
      const mimeType = appSettings.bestAudioFormat || 'audio/mp4';
      let extension = getFileExtension(mimeType);
      
      // Dateinamen mit Endung erstellen und eindeutig machen
      let timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 14);
      let fileName = `${baseName}_${timestamp}${extension}`;
      
      console.log("Upload starten: Datei", fileName, "Größe:", formatBytes(currentRecordingBlob.size), "Format:", mimeType);
      
      // Supabase Storage Upload
      supabaseClient.storage
        .from('podcast-audio')
        .upload(fileName, currentRecordingBlob, { 
          contentType: mimeType,
          upsert: true, // Überschreiben falls Datei existiert
          cacheControl: '0' // Vermeidet Caching
        })
        .then(function(response) {
          if (response.error) {
            throw response.error;
          }
          
          // Speichere in myUploads, dass diese Datei vom Benutzer hochgeladen wurde
          if (!myUploads.includes(fileName)) {
            myUploads.push(fileName);
            localStorage.setItem('myUploads', JSON.stringify(myUploads));
            appSettings.myUploads = myUploads;
          }
          
          // Erfolgsmeldung
          showSuccess("✅ Erfolgreich hochgeladen: " + fileName);
          currentRecordingBlob = null;
          
          // Lokale Aufnahme löschen
          clearSavedRecording();
          
          // Dateiliste aktualisieren
          refreshFileList();
        })
        .catch(function(error) {
          console.error("Upload-Fehler:", error);
          showError("❌ Fehler beim Upload: " + (error.message || "Verbindungsproblem"));
          uploadBtn.disabled = false;
        });
    }

    // --- 14) Dateien laden ---
    function loadFiles() {
      fileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      // Cache-Busting Parameter hinzufügen
      const cacheBuster = Date.now();
      
      supabaseClient.storage
        .from('podcast-audio')
        .list('', { 
          limit: 100, 
          sortBy: { column: 'created_at', order: 'desc' }
        })
        .then(function(response) {
          const files = response.data || [];
          const error = response.error;
          
          if (error) {
            throw error;
          }
          
          if (!files || files.length === 0) {
            fileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
            return;
          }
          
          fileList.innerHTML = "";
          
          // Zur Anzeige ausgewählte Dateien
          const visibleFiles = files.filter(function(file) {
            // Dateien anzeigen, die dem Benutzer gehören ODER öffentlich sind
            const userOwnsFile = myUploads.includes(file.name);
            const isPublic = isFilePublic(file.name);
            
            return userOwnsFile || isPublic;
          });
          
          if (visibleFiles.length === 0) {
            fileList.innerHTML = "<li>Keine sichtbaren Aufnahmen vorhanden</li>";
            return;
          }
          
          // Liste erstellen
          for (const file of visibleFiles) {
            const publicUrl = supabaseClient
              .storage
              .from('podcast-audio')
              .getPublicUrl(file.name).data.publicUrl;
            
            // Cache-Busting Parameter zum URL hinzufügen
            const noCacheUrl = publicUrl + (publicUrl.includes('?') ? '&' : '?') + '_cb=' + cacheBuster;
            
            const isPublic = isFilePublic(file.name);
            const isOwner = myUploads.includes(file.name);
            
            const li = document.createElement('li');
            if (isPublic) {
              li.className = 'public-file';
            }
            
            li.innerHTML = `
              <a href="${noCacheUrl}" target="_blank" download="${file.name}">
                ${file.name}
              </a>
              <span class="file-size">(${formatBytes(file.metadata?.size || 0)})</span>
              ${isPublic ? '<span class="file-visibility-icon">👁️</span>' : ''}
              ${isOwner ? ' (Meine Datei)' : ''}
            `;
            
            fileList.appendChild(li);
          }
        })
        .catch(function(err) {
          console.error("Fehler beim Laden der Dateien:", err);
          fileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien</li>";
        });
    }

    // --- 15) Admin-Bereich ---
    function handleAdminLogin() {
      const password = adminPasswordInput.value;
      
      if (password === "Luna") {
        hidePasswordModal();
        showAdminPanel();
      } else {
        alert("Falsches Passwort!");
      }
    }
    
    function showAdminPanel() {
      adminPanel.style.display = "block";
      appSettings.adminLoggedIn = true;
      loadAdminFilesByREST();
    }

    // --- 16) Admin-Dateien laden ---
    function loadAdminFiles() {
      adminFileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      // Cache-Busting Parameter hinzufügen
      const cacheBuster = Date.now();
      
      supabaseClient.storage
        .from('podcast-audio')
        .list('', { 
          limit: 100,
          offset: 0,
          sortBy: { column: 'created_at', order: 'desc' }
        })
        .then(function(response) {
          const files = response.data || [];
          const error = response.error;
          
          if (error) {
            throw error;
          }
          
          if (!files || files.length === 0) {
            adminFileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
            return;
          }
          
          adminFileList.innerHTML = "";
          
          // Admin-Liste erstellen
          for (const file of files) {
            const publicUrl = supabaseClient
              .storage
              .from('podcast-audio')
              .getPublicUrl(file.name).data.publicUrl;
            
            // Cache-Busting Parameter zum URL hinzufügen
            const noCacheUrl = publicUrl + (publicUrl.includes('?') ? '&' : '?') + '_cb=' + cacheBuster;
            
            const isPublic = isFilePublic(file.name);
            
            const li = document.createElement('li');
            li.className = isPublic ? 'public-file' : 'private-file';
            li.dataset.filename = file.name;
            
            li.innerHTML = `
              <a href="${noCacheUrl}" target="_blank">${file.name}</a>
              <span class="file-size">(${formatBytes(file.metadata?.size || 0)})</span>
              <span class="file-visibility">
                <span class="file-visibility-icon">${isPublic ? '👁️' : '🔒'}</span>
              </span>
              <button class="toggle-visibility" data-filename="${file.name}">
                ${isPublic ? 'Privat machen' : 'Öffentlich machen'}
              </button>
              <button class="delete" data-filename="${file.name}">Löschen</button>
            `;
            
            adminFileList.appendChild(li);
          }
        })
        .catch(function(err) {
          console.error("Fehler beim Laden der Admin-Dateien:", err);
          adminFileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien</li>";
        });
    }

    // --- 17) Admin-Dateiaktionen ---
    function handleAdminFileAction(e) {
      const target = e.target;
      
      // Datei löschen
      if (target.classList.contains("delete")) {
        const fileName = target.getAttribute("data-filename");
        
        if (!confirm(`Sind Sie sicher, dass Sie die Datei "${fileName}" löschen möchten?`)) {
          return;
        }
        
        // Anzeigen, dass die Löschung läuft
        target.textContent = "Wird gelöscht...";
        target.disabled = true;
        
        // Direkte REST-API verwenden statt Supabase-Client
        const encodedFileName = encodeURIComponent(fileName);
        const url = `${SUPABASE_URL}/storage/v1/object/podcast-audio/${encodedFileName}`;
        
        // HTTP-DELETE direkt mit fetch
        fetch(url, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache'
          }
        })
        .then(function(response) {
          if (!response.ok) {
            if (response.status === 404) {
              console.log("Datei wurde nicht gefunden (404), könnte bereits gelöscht sein");
              // Trotzdem als Erfolg behandeln
              return { success: true };
            }
            throw new Error(`HTTP-Status: ${response.status}`);
          }
          return { success: true };
        })
        .then(function() {
          console.log("Datei erfolgreich gelöscht:", fileName);
          
          // Aus der öffentlichen Liste entfernen
          if (publicFiles.includes(fileName)) {
            setFilePublic(fileName, false);
          }
          
          // Entferne aus myUploads
          if (myUploads.includes(fileName)) {
            myUploads = myUploads.filter(name => name !== fileName);
            localStorage.setItem('myUploads', JSON.stringify(myUploads));
            appSettings.myUploads = myUploads;
          }
          
          // Entferne das Element direkt aus der DOM
          const liElement = adminFileList.querySelector(`li[data-filename="${fileName}"]`);
          if (liElement) {
            liElement.remove();
          }
          
          showSuccess(`Datei '${fileName}' wurde gelöscht.`);
          
          // Dateilisten aktualisieren nach kurzer Verzögerung
          setTimeout(function() {
            // Direkt die Listen neu laden ohne Supabase-Client
            loadFilesByREST();
            loadAdminFilesByREST();
          }, 1000);
        })
        .catch(function(err) {
          console.error("Fehler beim Löschen:", err);
          showError(`Fehler beim Löschen: ${err.message || "Unbekannter Fehler"}`);
          target.textContent = "Löschen";
          target.disabled = false;
        });
      }
      
      // Sichtbarkeit ändern
      if (target.classList.contains("toggle-visibility")) {
        const fileName = target.getAttribute("data-filename");
        const makePublic = target.textContent.includes("Öffentlich machen");
        
        // Button-Status aktualisieren
        target.textContent = "Wird aktualisiert...";
        target.disabled = true;
        
        // Sichtbarkeit aktualisieren (lokal)
        setFilePublic(fileName, makePublic);
        
        // UI-Element direkt aktualisieren
        const liElement = target.closest('li');
        if (liElement) {
          liElement.className = makePublic ? 'public-file' : 'private-file';
          const iconElement = liElement.querySelector('.file-visibility-icon');
          if (iconElement) {
            iconElement.textContent = makePublic ? '👁️' : '🔒';
          }
        }
        
        // Button aktualisieren
        target.textContent = makePublic ? 'Privat machen' : 'Öffentlich machen';
        target.disabled = false;
        
        // Erfolgsmeldung
        showSuccess(`Datei '${fileName}' ist jetzt ${makePublic ? 'öffentlich' : 'privat'}.`);
        
        // Hauptliste aktualisieren mit Verzögerung
        setTimeout(function() {
          loadFilesByREST();
        }, 500);
      }
    }
    
    // --- 18) Alles herunterladen (ZIP) ---
    function downloadAllFiles() {
      showMessage("ZIP-Datei wird vorbereitet...", false);
      
      supabaseClient.storage
        .from('podcast-audio')
        .list('', { 
          limit: 100, 
          sortBy: { column: 'name', order: 'asc' }
        })
        .then(function(response) {
          const data = response.data || [];
          
          if (!data || data.length === 0) {
            showWarning("Keine Dateien zum Herunterladen vorhanden.");
            return;
          }
          
          // ZIP-Datei erstellen
          const zip = new JSZip();
          let completedDownloads = 0;
          let failedDownloads = 0;
          
          // Fortschritt anzeigen
          showMessage(`Lade 0/${data.length} Dateien...`, false);
          
          // Alle Dateien herunterladen und zum ZIP hinzufügen
          const downloadPromises = data.map(function(file) {
            const fileName = file.name;
            const fileUrl = supabaseClient
              .storage
              .from('podcast-audio')
              .getPublicUrl(fileName).data.publicUrl;
            
            return new Promise(function(resolve) {
              let attempts = 0;
              
              function attemptDownload() {
                // Cache-Buster hinzufügen
                const cacheBustedUrl = fileUrl + (fileUrl.includes('?') ? '&' : '?') + 'cb=' + Date.now();
                
                fetch(cacheBustedUrl)
                  .then(function(response) {
                    if (!response.ok) throw new Error(`HTTP Fehler: ${response.status}`);
                    return response.blob();
                  })
                  .then(function(blob) {
                    zip.file(fileName, blob);
                    completedDownloads++;
                    showMessage(`Lade ${completedDownloads}/${data.length} Dateien...`, false);
                    resolve();
                  })
                  .catch(function(fetchError) {
                    attempts++;
                    if (attempts < 3) {
                      setTimeout(attemptDownload, 1000); // 1s warten
                    } else {
                      console.error(`Fehler beim Laden von ${fileName}:`, fetchError);
                      failedDownloads++;
                      resolve(); // Trotzdem auflösen
                    }
                  });
              }
              
              attemptDownload();
            });
          });
          
          // Warten bis alle Downloads abgeschlossen sind
          Promise.all(downloadPromises)
            .then(function() {
              // ZIP erstellen und herunterladen
              showMessage("ZIP-Datei wird erstellt...", false);
              return zip.generateAsync({ type: "blob" });
            })
            .then(function(content) {
              // Aktuelles Datum für Dateinamen
              const date = new Date();
              const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
              
              saveAs(content, `podcast-aufnahmen-${dateStr}.zip`);
              
              if (failedDownloads > 0) {
                showWarning(`ZIP-Datei erstellt mit ${completedDownloads} Dateien. ${failedDownloads} Dateien konnten nicht geladen werden.`);
              } else {
                showSuccess("ZIP-Datei wurde erstellt und heruntergeladen.");
              }
            });
        })
        .catch(function(err) {
          showError("Fehler beim ZIP-Erstellen: " + err.message);
        });
    }

    // --- 19) Visualizer Funktionen ---
    function startVisualizer(stream) {
      try {
        // AudioContext erstellen
        audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        // Visualizer starten
        animateVisualizer();
      } catch (error) {
        console.warn("Visualizer konnte nicht initialisiert werden:", error);
        // Wir brechen die Aufnahme nicht ab, nur weil der Visualizer nicht funktioniert
      }
    }
    
    function animateVisualizer() {
      if (!analyser) return;
      
      try {
        animationId = requestAnimationFrame(animateVisualizer);
        analyser.getByteTimeDomainData(dataArray);
        
        // RMS (Root Mean Square) Berechnung für Lautstärke
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          const val = dataArray[i] - 128;
          sum += val * val;
        }
        
        const rms = Math.sqrt(sum / dataArray.length);
        const size = 40 + rms; // Basisgröße + Lautstärke
        
        // Kreisgröße aktualisieren
        visualizerCircle.style.width = size + "px";
        visualizerCircle.style.height = size + "px";
      } catch (error) {
        console.warn("Visualizer-Fehler:", error);
        cancelAnimationFrame(animationId);
      }
    }
    
    function pauseVisualizer() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }
    
    function resumeVisualizer() {
      if (audioContext && analyser) {
        animateVisualizer();
      }
    }
    
    function stopVisualizer() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      if (audioContext) {
        try {
          audioContext.close();
        } catch (e) {
          console.warn("Fehler beim Schließen des AudioContext:", e);
        }
        audioContext = null;
      }
      
      // Kreisgröße zurücksetzen
      visualizerCircle.style.width = "40px";
      visualizerCircle.style.height = "40px";
    }

    // --- 20) Timer Funktionen ---
    function startTimer() {
      recordingTime = 0;
      updateTimerDisplay(0);
      recordingInterval = setInterval(function() {
        recordingTime++;
        updateTimerDisplay(recordingTime);
      }, 1000);
    }
    
    function pauseTimer() {
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }
    
    function resumeTimer() {
      if (!recordingInterval) {
        recordingInterval = setInterval(function() {
          recordingTime++;
          updateTimerDisplay(recordingTime);
        }, 1000);
      }
    }
    
    function stopTimer() {
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }
    
    function updateTimerDisplay(seconds) {
      const mm = String(Math.floor(seconds / 60)).padStart(2, "0");
      const ss = String(seconds % 60).padStart(2, "0");
      timerDisplay.textContent = `${mm}:${ss}`;
    }

    // --- 21) UI-Hilfsfunktionen ---
    function updateRecordingUI(isActive, isPaused = false) {
      // Aufnahme aktiv
      if (isActive) {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        // Pause-Status
        if (isPaused) {
          pauseBtn.disabled = true;
          resumeBtn.disabled = false;
          recordingStatus.innerHTML = '<span class="status-icon">⏸️</span> Aufnahme pausiert';
        } else {
          pauseBtn.disabled = false;
          resumeBtn.disabled = true;
          recordingStatus.innerHTML = '<span class="recording-indicator"></span> Aufnahme läuft';
        }
      } 
      // Aufnahme inaktiv
      else {
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;
        recordingStatus.innerHTML = '';
      }
      
      // Immer dateiname prüfen
      validateFileName();
    }
    
    function showMessage(message, isRecording = false) {
      if (isRecording) {
        uploadStatus.innerHTML = `<span class="recording-indicator"></span> ${message}`;
      } else {
        uploadStatus.textContent = message;
      }
    }
    
    function showError(message) {
      uploadStatus.innerHTML = `<span class="error-message">❌ ${message}</span>`;
      console.error(message);
    }
    
    function showWarning(message) {
      uploadStatus.innerHTML = `<span style="color: #FF9800;">⚠️ ${message}</span>`;
      console.warn(message);
    }
    
    function showSuccess(message) {
      uploadStatus.innerHTML = `<span class="success-message">${message}</span>`;
    }
    
    // --- 22) Lokale Speicherung ---
    function saveRecording(blob, mimeType) {
      try {
        // In IndexedDB speichern (vereinfacht mit localStorage)
        localStorage.setItem('lastRecordingMimeType', mimeType);
        
        // Blob als Base64 speichern
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          const base64data = reader.result;
          localStorage.setItem('lastRecordingData', base64data);
        };
      } catch (err) {
        console.warn("Konnte Aufnahme nicht lokal speichern:", err);
      }
    }
    
    // Speichert aktuelle Audiochunks (für Wiederherstellung)
    function saveRecordingChunks() {
      // Wir speichern hier nicht die Chunks selbst, da das zu viel wäre
      // Stattdessen markieren wir, dass eine Aufnahme läuft
      if (isRecording) {
        localStorage.setItem('recordingInProgress', 'true');
      }
    }
    
    function clearSavedRecording() {
      localStorage.removeItem('lastRecordingData');
      localStorage.removeItem('lastRecordingMimeType');
      localStorage.removeItem('recordingInProgress');
    }
    
    function checkForSavedRecording() {
      const savedRecording = localStorage.getItem('lastRecordingData');
      const savedMimeType = localStorage.getItem('lastRecordingMimeType');
      
      if (savedRecording && savedMimeType) {
        // Vorherige Aufnahme wiederherstellen
        try {
          // Base64 in Blob umwandeln
          const byteString = atob(savedRecording.split(',')[1]);
          const ab = new ArrayBuffer(byteString.length);
          const ia = new Uint8Array(ab);
          
          for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
          }
          
          currentRecordingBlob = new Blob([ab], { type: savedMimeType });
          const audioUrl = URL.createObjectURL(currentRecordingBlob);
          audioPlayer.src = audioUrl;
          
          // UI aktualisieren
          uploadBtn.disabled = false;
          showMessage("Gespeicherte Aufnahme geladen. Sie können sie hochladen oder eine neue erstellen.");
        } catch (err) {
          console.warn("Fehler beim Laden der gespeicherten Aufnahme:", err);
          clearSavedRecording();
        }
      }
      
      // Prüfe, ob eine Aufnahme unterbrochen wurde
      const inProgress = localStorage.getItem('recordingInProgress');
      if (inProgress === 'true') {
        showWarning("Eine frühere Aufnahme wurde unterbrochen. Bitte starten Sie eine neue Aufnahme.");
        localStorage.removeItem('recordingInProgress');
      }
    }
    
    // --- 23) Hilfsfunktionen ---
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';
      
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    
    // --- 24) Fenster geladen ---
    window.addEventListener('DOMContentLoaded', function() {
      // Initialisierung starten
      init();
    });
  </script>
</body>
</html>