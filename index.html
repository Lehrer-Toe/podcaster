<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Podcast Aufnahme – WebM mit Supabase</title>

  <!-- JSZip & FileSaver für „Alles herunterladen" -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <style>
    /* --- Allgemeine Styles --- */
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #f8f9fa;
      color: #333;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }
    
    /* --- Header --- */
    header {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: #fff;
      padding: 1.5rem;
      text-align: center;
      box-shadow: 0 2px 15px rgba(0,0,0,0.1);
    }
    
    /* --- Container --- */
    .container {
      max-width: 700px;
      margin: 2rem auto;
      background: #fff;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.06);
    }
    
    @media (max-width: 768px) {
      .container {
        margin: 1rem;
        padding: 1.5rem;
      }
    }
    
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
      font-weight: 600;
    }
    
    h2 {
      font-size: 1.4rem;
      margin-bottom: 1rem;
      color: #2E7D32;
    }
    
    /* --- Aufnahme-Controls --- */
    .record-controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    
    @media (min-width: 600px) {
      .record-controls {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    .filename-input-container {
      position: relative;
      grid-column: 1 / -1;
    }
    
    input[type="text"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      transition: all 0.2s ease;
      -webkit-appearance: none;
      appearance: none;
    }
    
    input[type="text"]:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
    }
    
    .input-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #444;
    }
    
    /* --- Button Styles --- */
    button {
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      color: #fff;
      background: #4CAF50;
      transition: all 0.2s ease;
      -webkit-appearance: none;
      appearance: none;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 48px; /* Für bessere Touch-Ziele auf iPads */
    }
    
    button:hover:not(:disabled) {
      background: #45a049;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0,0,0,0.1);
    }
    
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    
    button:disabled {
      background: #e0e0e0;
      color: #999;
      cursor: not-allowed;
    }
    
    button:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3);
    }
    
    /* --- Spezielle Button-Typen --- */
    #startBtn {
      background: #4CAF50;
    }
    
    #startBtn:hover:not(:disabled) {
      background: #3e9142;
    }
    
    #pauseBtn {
      background: #FF9800;
    }
    
    #pauseBtn:hover:not(:disabled) {
      background: #F57C00;
    }
    
    #resumeBtn {
      background: #2196F3;
    }
    
    #resumeBtn:hover:not(:disabled) {
      background: #1976D2;
    }
    
    #stopBtn {
      background: #f44336;
    }
    
    #stopBtn:hover:not(:disabled) {
      background: #d32f2f;
    }
    
    #uploadBtn {
      background: #673AB7;
    }
    
    #uploadBtn:hover:not(:disabled) {
      background: #5E35B1;
    }
    
    /* --- Audio Format Auswahl --- */
    .audio-format-control {
      display: flex;
      flex-direction: column;
      margin-bottom: 1.5rem;
    }
    
    select {
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      background-color: #fff;
      -webkit-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23131313%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 1rem top 50%;
      background-size: 0.65rem auto;
      cursor: pointer;
    }
    
    select:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
    }
    
    /* --- Status-Anzeigen --- */
    .status-bar {
      display: flex;
      align-items: center;
      margin-bottom: 1rem;
      padding: 0.5rem 0;
      min-height: 2rem;
    }
    
    #timerDisplay {
      text-align: center;
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      color: #2E7D32;
    }
    
    /* --- Audio Player --- */
    audio {
      width: 100%;
      margin: 1.5rem 0;
      border-radius: 8px;
    }
    
    #uploadStatus {
      margin: 1rem 0;
      font-weight: 500;
      padding: 0.75rem;
      border-radius: 8px;
      background: #f5f5f5;
      min-height: 3rem;
      display: flex;
      align-items: center;
    }
    
    /* --- Visualizer --- */
    .visualizer-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 20px auto 40px auto;
      border: 2px solid #e0e0e0;
      border-radius: 50%;
      background: #fafafa;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
    }
    
    .visualizer-circle {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #f44336;
      border-radius: 50%;
      transition: width 0.1s, height 0.1s;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    }
    
    /* --- Tabs --- */
    .tab-container {
      margin-top: 2.5rem;
    }
    
    .tab-buttons {
      display: flex;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 1.5rem;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .tab-button {
      background: transparent;
      border: none;
      padding: 0.75rem 1.5rem;
      margin-right: 0.5rem;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      color: #666;
      font-weight: 500;
      min-width: auto;
    }
    
    .tab-button.active {
      background: #4CAF50;
      color: white;
    }
    
    .tab-content {
      display: none;
      padding: 1rem 0;
    }
    
    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* --- Dateien-Liste --- */
    .file-list, .admin-panel {
      margin-top: 2rem;
    }
    
    .file-list h2, .admin-panel h2 {
      margin-bottom: 1rem;
    }
    
    .file-list ul, .admin-panel ul {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }
    
    .file-list li, .admin-panel li {
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 8px;
      background: #f8f9fa;
      transition: all 0.2s ease;
    }
    
    .file-list li:hover, .admin-panel li:hover {
      background: #f0f0f0;
    }
    
    .file-list a, .admin-panel a {
      color: #4CAF50;
      text-decoration: none;
      flex: 1;
      padding: 0.25rem 0;
    }
    
    .file-list a:hover, .admin-panel a:hover {
      text-decoration: underline;
    }
    
    /* --- Admin Panel --- */
    .admin-panel {
      display: none;
      border-top: 1px solid #e0e0e0;
      padding-top: 1.5rem;
      margin-top: 2rem;
    }
    
    .admin-panel button.delete {
      background: #f44336;
      padding: 0.5rem 0.75rem;
      margin-left: 0.75rem;
      font-size: 0.9rem;
    }
    
    .admin-panel button.delete:hover {
      background: #d32f2f;
    }
    
    #adminLoginBtn {
      background: #333;
      margin-top: 2rem;
    }
    
    #closeAdminBtn {
      background: #333;
    }
    
    /* --- Indikatoren und Animationen --- */
    .recording-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f44336;
      margin-right: 8px;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    
    .status-icon {
      margin-right: 5px;
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
      100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
    }
    
    .error-message {
      color: #f44336;
      font-weight: 500;
    }
    
    .success-message {
      color: #4CAF50;
      font-weight: 500;
    }
    
    /* Verbesserte iPad-spezifische Styles */
    @media (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2), 
           (max-width: 1024px) and (min-resolution: 192dpi) {
      button, input, select {
        font-size: 1.1rem;
        padding: 0.85rem 1rem;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .visualizer-container {
        width: 180px;
        height: 180px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Podcast Aufnahme – Audio Recorder</h1>
  </header>

  <div class="container">
    <!-- Aufnahme-Steuerung -->
    <div class="record-controls">
      <div class="filename-input-container">
        <label for="filename" class="input-label">Dateiname (Pflicht)</label>
        <input type="text" id="filename" placeholder="Bitte Dateinamen eingeben" />
      </div>
      <button id="startBtn">Aufnahme starten</button>
      <button id="pauseBtn" disabled>Pausieren</button>
      <button id="resumeBtn" disabled>Fortsetzen</button>
      <button id="stopBtn" disabled>Stoppen</button>
      <button id="uploadBtn" disabled>Hochladen</button>
    </div>

    <!-- Audio-Format Auswahl -->
    <div class="audio-format-control">
      <label for="audioFormat" class="input-label">Audio-Format</label>
      <select id="audioFormat">
        <option value="audio/webm">WebM (Standard)</option>
        <option value="audio/ogg;codecs=opus">Ogg Opus</option>
        <option value="audio/mpeg">MP3 (falls unterstützt)</option>
      </select>
    </div>

    <!-- Status-Anzeige -->
    <div class="status-bar">
      <span id="recordingStatus"></span>
    </div>

    <!-- Timer-Anzeige -->
    <div id="timerDisplay">00:00</div>

    <!-- Audio-Vorschau & Status -->
    <audio id="audioPlayer" controls></audio>
    <p id="uploadStatus"></p>

    <!-- Visueller Lautstärke-Indikator -->
    <div class="visualizer-container">
      <div class="visualizer-circle" id="visualizerCircle"></div>
    </div>

    <!-- Tab-Navigation -->
    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="recordings">Aufnahmen</button>
        <button class="tab-button" data-tab="help">Hilfe</button>
      </div>
      
      <!-- Aufnahmen Tab -->
      <div class="tab-content active" id="recordings-tab">
        <!-- Öffentliche Dateiliste -->
        <div class="file-list">
          <h2>Vorhandene Aufnahmen</h2>
          <ul id="fileList"></ul>
        </div>
      </div>
      
      <!-- Hilfe Tab -->
      <div class="tab-content" id="help-tab">
        <h2>Verwendung</h2>
        <ol>
          <li>Geben Sie einen Dateinamen ein</li>
          <li>Wählen Sie das gewünschte Audioformat</li>
          <li>Klicken Sie auf "Aufnahme starten"</li>
          <li>Sie können die Aufnahme pausieren und fortsetzen</li>
          <li>Nach dem Stoppen können Sie die Aufnahme anhören</li>
          <li>Klicken Sie auf "Hochladen", um die Aufnahme zu speichern</li>
        </ol>
        <p><strong>Hinweis:</strong> Ihr Browser speichert die letzte Aufnahme lokal. Sie können die Seite neu laden, ohne die Aufnahme zu verlieren.</p>
      </div>
    </div>

    <!-- Admin-Oberfläche -->
    <div class="admin-panel" id="adminPanel">
      <h2>Admin-Oberfläche</h2>
      <button id="downloadAllBtn">Alles herunterladen</button>
      <ul id="adminFileList"></ul>
      <button id="closeAdminBtn">Admin schließen</button>
    </div>

    <!-- Admin-Login Button -->
    <button id="adminLoginBtn">Admin Login</button>
  </div>

  <!-- Supabase (ES-Modul) -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

    // --- 1) SUPABASE KONFIG --- 
    // Diese Werte sollten idealerweise über eine Server-Umgebungsvariable kommen
    // Hier nur für Demo-Zwecke im Client - für Produktion nicht empfohlen
    const SUPABASE_URL = "https://DEINE-URL.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6bXpscnNmdWVwYmtxd3picmlyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE5NTkxMzAsImV4cCI6MjA1NzUzNTEzMH0.zLZDSfylloUxlxYPEpfO4VMAdf0cNpUzKH2T9qv8ezI";
    
    // Initialisiere Supabase Client
    let supabaseClient;
    try {
      supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      console.log("Supabase Client erfolgreich initialisiert");
    } catch (err) {
      console.error("Fehler bei der Supabase-Initialisierung:", err);
      showError("Verbindungsfehler: Bitte später erneut versuchen.");
    }

    // --- 2) Variablen ---
    let mediaRecorder;
    let audioStream;
    let audioChunks = [];
    let currentRecordingBlob = null;
    let audioContext, analyser, dataArray, animationId;
    let recordingTime = 0;
    let recordingInterval = null;
    let isPaused = false;
    let isRecording = false;
    
    // Für die Anwendungseinstellungen
    const appSettings = {
      adminLoggedIn: false,
      lastFormat: localStorage.getItem('preferredFormat') || 'audio/webm',
      lastFileName: localStorage.getItem('lastFileName') || ''
    };

    // --- 3) DOM-Elemente ---
    const filenameInput    = document.getElementById("filename");
    const startBtn         = document.getElementById("startBtn");
    const pauseBtn         = document.getElementById("pauseBtn");
    const resumeBtn        = document.getElementById("resumeBtn");
    const stopBtn          = document.getElementById("stopBtn");
    const uploadBtn        = document.getElementById("uploadBtn");
    const audioPlayer      = document.getElementById("audioPlayer");
    const uploadStatus     = document.getElementById("uploadStatus");
    const fileList         = document.getElementById("fileList");
    const adminPanel       = document.getElementById("adminPanel");
    const adminFileList    = document.getElementById("adminFileList");
    const adminLoginBtn    = document.getElementById("adminLoginBtn");
    const closeAdminBtn    = document.getElementById("closeAdminBtn");
    const visualizerCircle = document.getElementById("visualizerCircle");
    const downloadAllBtn   = document.getElementById("downloadAllBtn");
    const timerDisplay     = document.getElementById("timerDisplay");
    const recordingStatus  = document.getElementById("recordingStatus");
    const audioFormat      = document.getElementById("audioFormat");
    const tabButtons       = document.querySelectorAll(".tab-button");
    const tabContents      = document.querySelectorAll(".tab-content");

    // --- 4) Initialisierung ---
    function init() {
      // Lade gespeicherte Einstellungen aus dem LocalStorage
      if (appSettings.lastFileName) {
        filenameInput.value = appSettings.lastFileName;
        validateFileName(); // Wichtig: Hier wurde ein Bug behoben!
      }
      
      if (appSettings.lastFormat) {
        audioFormat.value = appSettings.lastFormat;
      }
      
      // Prüfe Browser-Unterstützung
      checkBrowserSupport();
      
      // Lade vorhandene Dateien
      loadFiles();
      
      // Setze Event Listeners
      setupEventListeners();
      
      // Prüfe, ob es eine gespeicherte Aufnahme gibt
      checkForSavedRecording();
    }

    // --- 5) Browser-Unterstützung prüfen ---
    function checkBrowserSupport() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showError("Ihr Browser unterstützt keine Audioaufnahmen. Bitte verwenden Sie einen modernen Browser wie Chrome, Firefox oder Edge.");
        startBtn.disabled = true;
        return false;
      }
      return true;
    }

    // --- 6) Event Listeners ---
    function setupEventListeners() {
      // Dateiname-Validierung
      filenameInput.addEventListener("input", validateFileName);
      
      // Format-Änderung
      audioFormat.addEventListener("change", () => {
        localStorage.setItem('preferredFormat', audioFormat.value);
      });
      
      // Aufnahme-Steuerung
      startBtn.addEventListener("click", startRecording);
      pauseBtn.addEventListener("click", pauseRecording);
      resumeBtn.addEventListener("click", resumeRecording);
      stopBtn.addEventListener("click", stopRecording);
      uploadBtn.addEventListener("click", uploadRecording);
      
      // Admin-Bereich
      adminLoginBtn.addEventListener("click", handleAdminLogin);
      closeAdminBtn.addEventListener("click", () => {
        adminPanel.style.display = "none";
        appSettings.adminLoggedIn = false;
      });
      downloadAllBtn.addEventListener("click", downloadAllFiles);
      
      // Tab-Navigation
      tabButtons.forEach(button => {
        button.addEventListener("click", () => {
          const tabId = button.dataset.tab;
          
          // Aktiven Tab wechseln
          tabButtons.forEach(btn => btn.classList.remove("active"));
          tabContents.forEach(content => content.classList.remove("active"));
          
          button.classList.add("active");
          document.getElementById(`${tabId}-tab`).classList.add("active");
        });
      });

      // Dateiliste Löschen (nur für Admin)
      adminFileList.addEventListener("click", handleAdminFileAction);
    }

    // --- 7) Dateiname-Validierung ---
    function validateFileName() {
      const filename = filenameInput.value.trim();
      
      if (filename) {
        startBtn.disabled = false;
        localStorage.setItem('lastFileName', filename);
      } else {
        startBtn.disabled = true;
      }

      // Debug-Information zur Hilfe
      console.log("Dateiname validiert:", filename, "Start-Button aktiviert:", !startBtn.disabled);
    }

    // --- 8) Aufnahme starten ---
    async function startRecording() {
      const filename = filenameInput.value.trim();
      
      if (!filename) {
        showError("Bitte erst einen Dateinamen eingeben!");
        return;
      }
      
      if (!checkBrowserSupport()) return;
      
      try {
        // Audiostream anfordern
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Prüfe, ob das gewählte Format unterstützt wird
        const selectedFormat = audioFormat.value;
        const options = { mimeType: selectedFormat };
        
        // Prüfe, ob das Format unterstützt wird
        if (!MediaRecorder.isTypeSupported(selectedFormat)) {
          showWarning(`Format ${selectedFormat} wird nicht unterstützt. Fallback auf WebM.`);
          options.mimeType = "audio/webm";
          audioFormat.value = "audio/webm";
        }
        
        // MediaRecorder initialisieren
        mediaRecorder = new MediaRecorder(audioStream, options);
        audioChunks = [];
        
        // Event Handling
        mediaRecorder.ondataavailable = handleDataAvailable;
        mediaRecorder.onstop = handleRecordingStop;
        mediaRecorder.onpause = handleRecordingPause;
        mediaRecorder.onresume = handleRecordingResume;
        mediaRecorder.onerror = (event) => {
          showError("Aufnahmefehler: " + event.error);
        };
        
        // Aufnahme starten
        mediaRecorder.start(1000); // Chunks alle 1 Sekunde
        isRecording = true;
        isPaused = false;
        
        // UI aktualisieren
        updateRecordingUI(true);
        
        // Visualizer und Timer starten
        startVisualizer(audioStream);
        startTimer();
        
        showMessage("Aufnahme läuft...", true);
      } catch (err) {
        showError("Mikrofon-Zugriff nicht erlaubt oder nicht verfügbar.");
        console.error("Aufnahmefehler:", err);
      }
    }
    
    // --- 9) Aufnahme pausieren ---
    function pauseRecording() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.pause();
        isPaused = true;
        pauseTimer();
        pauseVisualizer();
        updateRecordingUI(true, true);
        showMessage("Aufnahme pausiert", false);
      }
    }
    
    // --- 10) Aufnahme fortsetzen ---
    function resumeRecording() {
      if (mediaRecorder && mediaRecorder.state === "paused") {
        mediaRecorder.resume();
        isPaused = false;
        resumeTimer();
        resumeVisualizer();
        updateRecordingUI(true, false);
        showMessage("Aufnahme fortgesetzt", true);
      }
    }

    // --- 11) Aufnahme stoppen ---
    function stopRecording() {
      if (mediaRecorder && (mediaRecorder.state === "recording" || mediaRecorder.state === "paused")) {
        mediaRecorder.stop();
        isRecording = false;
        isPaused = false;
        
        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
        }
        
        stopTimer();
        stopVisualizer();
        updateRecordingUI(false);
      }
    }

    // --- 12) Media Recorder Event Handler ---
    function handleDataAvailable(event) {
      if (event.data && event.data.size > 0) {
        audioChunks.push(event.data);
        // Speichere den aktuellen Stand im LocalStorage
        saveRecordingChunks();
      }
    }
    
    function handleRecordingStop() {
      // Erstelle Blob aus gesammelten Daten
      const mimeType = audioFormat.value;
      currentRecordingBlob = new Blob(audioChunks, { type: mimeType });
      
      // Audio-Player aktualisieren
      const audioUrl = URL.createObjectURL(currentRecordingBlob);
      audioPlayer.src = audioUrl;
      
      // UI aktualisieren
      uploadBtn.disabled = false;
      showMessage("Aufnahme bereit – bitte jetzt anhören und hochladen.", false);
      
      // Lokale Kopie speichern
      saveRecording(currentRecordingBlob, mimeType);
    }
    
    function handleRecordingPause() {
      showMessage("Aufnahme pausiert", false);
    }
    
    function handleRecordingResume() {
      showMessage("Aufnahme fortgesetzt", true);
    }

    // --- 13) Aufnahme hochladen ---
    async function uploadRecording() {
      if (!currentRecordingBlob) {
        showError("Keine Aufnahme vorhanden!");
        return;
      }
      
      showMessage("Wird hochgeladen...", false);
      uploadBtn.disabled = true;
      
      // Dateinamen vorbereiten
      let baseName = filenameInput.value.trim();
      const mimeType = audioFormat.value;
      let extension;
      
      // Dateiendung basierend auf MIME-Typ festlegen
      switch (mimeType) {
        case "audio/webm":
          extension = ".webm";
          break;
        case "audio/ogg;codecs=opus":
          extension = ".ogg";
          break;
        case "audio/mpeg":
          extension = ".mp3";
          break;
        default:
          extension = ".webm";
      }
      
      // Dateinamen mit Endung erstellen
      const fileName = baseName + extension;
      
      try {
        // Auf Supabase hochladen
        const { error } = await supabaseClient
          .storage
          .from('podcast-audio')
          .upload(fileName, currentRecordingBlob, { contentType: mimeType });
        
        if (error) {
          throw error;
        }
        
        // Erfolgsmeldung
        showSuccess("✅ Erfolgreich hochgeladen: " + fileName);
        currentRecordingBlob = null;
        
        // Lokale Aufnahme löschen
        clearSavedRecording();
        
        // Dateiliste aktualisieren
        loadFiles();
      } catch (error) {
        console.error("Upload-Fehler:", error);
        showError("❌ Fehler beim Upload: " + error.message);
        uploadBtn.disabled = false;
      }
    }

    // --- 14) Öffentliche Dateiliste laden ---
    async function loadFiles() {
      fileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      try {
        const { data, error } = await supabaseClient.storage
          .from('podcast-audio')
          .list('', { limit: 100, offset: 0, sortBy: { column: 'created_at', order: 'desc' } });
        
        if (error) {
          throw error;
        }
        
        fileList.innerHTML = "";
        
        if (!data || data.length === 0) {
          fileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
          return;
        }
        
        for (const file of data) {
          const { data: publicUrl } = supabaseClient
            .storage
            .from('podcast-audio')
            .getPublicUrl(file.name);
          
          const li = document.createElement('li');
          li.innerHTML = `
            <a href="${publicUrl.publicUrl}" target="_blank" download="${file.name}">
              ${file.name}
            </a>
            <span>(${formatBytes(file.metadata?.size || 0)})</span>
          `;
          fileList.appendChild(li);
        }
      } catch (err) {
        console.error("Fehler beim Laden der Dateien:", err);
        fileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien</li>";
      }
    }

    // --- 15) Admin-Bereich ---
    function handleAdminLogin() {
      // WARNUNG: In Produktion sollte das Passwort nicht im Client-Code sein
      // Besser: Server-seitige Authentifizierung
      const storedHash = localStorage.getItem('adminHash');
      
      if (storedHash) {
        // Hash aus LocalStorage verwenden (Nutzer bereits angemeldet)
        const pwd = prompt("Bitte Admin-Passwort eingeben:");
        
        if (pwd && hashPassword(pwd) === storedHash) {
          showAdminPanel();
        } else {
          alert("Falsches Passwort!");
        }
      } else {
        // Neues Passwort speichern (Demo-Zwecke)
        const pwd = prompt("Bitte Admin-Passwort eingeben:");
        
        if (pwd === "Luna") {
          // Passwort hashen und im LocalStorage speichern
          localStorage.setItem('adminHash', hashPassword(pwd));
          showAdminPanel();
        } else {
          alert("Falsches Passwort!");
        }
      }
    }
    
    function showAdminPanel() {
      adminPanel.style.display = "block";
      appSettings.adminLoggedIn = true;
      loadAdminFiles();
    }
    
    // Einfache Hash-Funktion (nur für Demo, nicht sicher!)
    function hashPassword(password) {
      let hash = 0;
      for (let i = 0; i < password.length; i++) {
        hash = ((hash << 5) - hash) + password.charCodeAt(i);
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash.toString(16);
    }

    // --- 16) Admin-Dateien laden ---
    async function loadAdminFiles() {
      adminFileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      try {
        const { data, error } = await supabaseClient.storage
          .from('podcast-audio')
          .list('', { limit: 100, offset: 0, sortBy: { column: 'created_at', order: 'desc' } });
        
        if (error) {
          throw error;
        }
        
        adminFileList.innerHTML = "";
        
        if (!data || data.length === 0) {
          adminFileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
          return;
        }
        
        for (const file of data) {
          const { data: publicUrl } = supabaseClient
            .storage
            .from('podcast-audio')
            .getPublicUrl(file.name);
          
          const li = document.createElement('li');
          li.innerHTML = `
            <a href="${publicUrl.publicUrl}" target="_blank">${file.name}</a>
            <span>(${formatBytes(file.metadata?.size || 0)})</span>
            <button class="delete" data-filename="${file.name}">Löschen</button>
          `;
          adminFileList.appendChild(li);
        }
      } catch (err) {
        console.error("Fehler beim Laden der Admin-Dateien:", err);
        adminFileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien</li>";
      }
    }

    // --- 17) Admin-Dateiaktionen ---
    async function handleAdminFileAction(e) {
      if (!e.target.classList.contains("delete")) return;
      
      const fileName = e.target.getAttribute("data-filename");
      
      if (!confirm(`Sind Sie sicher, dass Sie die Datei "${fileName}" löschen möchten?`)) {
        return;
      }
      
      try {
        const { error } = await supabaseClient
          .storage
          .from('podcast-audio')
          .remove([fileName]);
          
        if (error) {
          throw error;
        }
        
        showSuccess(`Datei '${fileName}' wurde gelöscht.`);
        loadFiles();
        loadAdminFiles();
      } catch (err) {
        showError("Fehler beim Löschen: " + err.message);
      }
    }

    // --- 18) Alles herunterladen (ZIP) ---
    async function downloadAllFiles() {
      showMessage("ZIP-Datei wird vorbereitet...", false);
      
      try {
        // Alle Dateien abrufen
        const { data, error } = await supabaseClient.storage
          .from('podcast-audio')
          .list('', { limit: 100, offset: 0, sortBy: { column: 'name', order: 'asc' } });
        
        if (error) {
          throw error;
        }
        
        if (!data || data.length === 0) {
          showWarning("Keine Dateien zum Herunterladen vorhanden.");
          return;
        }
        
        // ZIP-Datei erstellen
        const zip = new JSZip();
        let completedDownloads = 0;
        
        // Fortschritt anzeigen
        showMessage(`Lade 0/${data.length} Dateien...`, false);
        
        // Alle Dateien herunterladen und zum ZIP hinzufügen
        for (const file of data) {
          const fileName = file.name;
          const { data: publicUrlData } = supabaseClient
            .storage
            .from('podcast-audio')
            .getPublicUrl(fileName);
            
          const fileUrl = publicUrlData.publicUrl;
          
          try {
            const response = await fetch(fileUrl);
            const blob = await response.blob();
            zip.file(fileName, blob);
            
            completedDownloads++;
            showMessage(`Lade ${completedDownloads}/${data.length} Dateien...`, false);
          } catch (fetchError) {
            console.error(`Fehler beim Laden von ${fileName}:`, fetchError);
            // Fehler für einzelne Dateien ignorieren, aber loggen
          }
        }
        
        // ZIP erstellen und herunterladen
        showMessage("ZIP-Datei wird erstellt...", false);
        const content = await zip.generateAsync({ type: "blob" });
        
        // Aktuelles Datum für Dateinamen
        const date = new Date();
        const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        
        saveAs(content, `podcast-aufnahmen-${dateStr}.zip`);
        showSuccess("ZIP-Datei wurde erstellt und heruntergeladen.");
      } catch (err) {
        showError("Fehler beim ZIP-Erstellen: " + err.message);
      }
    }

    // --- 19) Visualizer Funktionen ---
    function startVisualizer(stream) {
      // AudioContext erstellen
      audioContext = new AudioContext();
      const source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 1024;
      source.connect(analyser);
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      
      // Visualizer starten
      animateVisualizer();
    }
    
    function animateVisualizer() {
      if (!analyser) return;
      
      animationId = requestAnimationFrame(animateVisualizer);
      analyser.getByteTimeDomainData(dataArray);
      
      // RMS (Root Mean Square) Berechnung für Lautstärke
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const val = dataArray[i] - 128;
        sum += val * val;
      }
      
      const rms = Math.sqrt(sum / dataArray.length);
      const size = 40 + rms; // Basisgröße + Lautstärke
      
      // Kreisgröße aktualisieren
      visualizerCircle.style.width = size + "px";
      visualizerCircle.style.height = size + "px";
    }
    
    function pauseVisualizer() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }
    
    function resumeVisualizer() {
      if (audioContext && analyser) {
        animateVisualizer();
      }
    }
    
    function stopVisualizer() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      
      // Kreisgröße zurücksetzen
      visualizerCircle.style.width = "40px";
      visualizerCircle.style.height = "40px";
    }

    // --- 20) Timer Funktionen ---
    function startTimer() {
      recordingTime = 0;
      updateTimerDisplay(0);
      recordingInterval = setInterval(() => {
        recordingTime++;
        updateTimerDisplay(recordingTime);
      }, 1000);
    }
    
    function pauseTimer() {
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }
    
    function resumeTimer() {
      if (!recordingInterval) {
        recordingInterval = setInterval(() => {
          recordingTime++;
          updateTimerDisplay(recordingTime);
        }, 1000);
      }
    }
    
    function stopTimer() {
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }
    
    function updateTimerDisplay(seconds) {
      const mm = String(Math.floor(seconds / 60)).padStart(2, "0");
      const ss = String(seconds % 60).padStart(2, "0");
      timerDisplay.textContent = `${mm}:${ss}`;
    }

    // --- 21) UI-Hilfsfunktionen ---
    function updateRecordingUI(isActive, isPaused = false) {
      // Aufnahme aktiv
      if (isActive) {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        // Pause-Status
        if (isPaused) {
          pauseBtn.disabled = true;
          resumeBtn.disabled = false;
          recordingStatus.innerHTML = '<span class="status-icon">⏸️</span> Aufnahme pausiert';
        } else {
          pauseBtn.disabled = false;
          resumeBtn.disabled = true;
          recordingStatus.innerHTML = '<span class="recording-indicator"></span> Aufnahme läuft';
        }
      } 
      // Aufnahme inaktiv
      else {
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;
        recordingStatus.innerHTML = '';
      }
    }
    
    function showMessage(message, isRecording = false) {
      if (isRecording) {
        uploadStatus.innerHTML = `<span class="recording-indicator"></span> ${message}`;
      } else {
        uploadStatus.textContent = message;
      }
    }
    
    function showError(message) {
      uploadStatus.innerHTML = `<span class="error-message">❌ ${message}</span>`;
      console.error(message);
    }
    
    function showWarning(message) {
      uploadStatus.innerHTML = `<span style="color: #FF9800;">⚠️ ${message}</span>`;
      console.warn(message);
    }
    
    function showSuccess(message) {
      uploadStatus.innerHTML = `<span class="success-message">${message}</span>`;
    }
    
    // --- 22) Lokale Speicherung ---
    function saveRecording(blob, mimeType) {
      try {
        // In IndexedDB speichern (vereinfacht mit localStorage)
        localStorage.setItem('lastRecordingMimeType', mimeType);
        
        // Blob als Base64 speichern
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          const base64data = reader.result;
          localStorage.setItem('lastRecordingData', base64data);
        };
      } catch (err) {
        console.warn("Konnte Aufnahme nicht lokal speichern:", err);
      }
    }
    
    // Speichert aktuelle Audiochunks (für Wiederherstellung)
    function saveRecordingChunks() {
      // Wir speichern hier nicht die Chunks selbst, da das zu viel wäre
      // Stattdessen markieren wir, dass eine Aufnahme läuft
      if (isRecording) {
        localStorage.setItem('recordingInProgress', 'true');
      }
    }
    
    function clearSavedRecording() {
      localStorage.removeItem('lastRecordingData');
      localStorage.removeItem('lastRecordingMimeType');
      localStorage.removeItem('recordingInProgress');
    }
    
    function checkForSavedRecording() {
      const savedRecording = localStorage.getItem('lastRecordingData');
      const savedMimeType = localStorage.getItem('lastRecordingMimeType');
      
      if (savedRecording && savedMimeType) {
        // Vorherige Aufnahme wiederherstellen
        try {
          // Base64 in Blob umwandeln
          const byteString = atob(savedRecording.split(',')[1]);
          const ab = new ArrayBuffer(byteString.length);
          const ia = new Uint8Array(ab);
          
          for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
          }
          
          currentRecordingBlob = new Blob([ab], { type: savedMimeType });
          const audioUrl = URL.createObjectURL(currentRecordingBlob);
          audioPlayer.src = audioUrl;
          
          // UI aktualisieren
          uploadBtn.disabled = false;
          showMessage("Gespeicherte Aufnahme geladen. Sie können sie hochladen oder eine neue erstellen.");
        } catch (err) {
          console.warn("Fehler beim Laden der gespeicherten Aufnahme:", err);
          clearSavedRecording();
        }
      }
      
      // Prüfe, ob eine Aufnahme unterbrochen wurde
      const inProgress = localStorage.getItem('recordingInProgress');
      if (inProgress === 'true') {
        showWarning("Eine frühere Aufnahme wurde unterbrochen. Bitte starten Sie eine neue Aufnahme.");
        localStorage.removeItem('recordingInProgress');
      }
    }
    
    // --- 23) Hilfsfunktionen ---
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';
      
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    
    // --- 24) Initialisierung starten ---
    init();
  </script>
</body>
</html>