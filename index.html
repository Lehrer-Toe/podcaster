<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Podcast Aufnahme ‚Äì iOS kompatibel</title>

  <!-- JSZip & FileSaver f√ºr ‚ÄûAlles herunterladen" -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <style>
    /* --- Allgemeine Styles --- */
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #f8f9fa;
      color: #333;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }
    
    /* --- Header --- */
    header {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: #fff;
      padding: 1.5rem;
      text-align: center;
      box-shadow: 0 2px 15px rgba(0,0,0,0.1);
    }
    
    /* --- Container --- */
    .container {
      max-width: 700px;
      margin: 2rem auto;
      background: #fff;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.06);
    }
    
    @media (max-width: 768px) {
      .container {
        margin: 1rem;
        padding: 1.5rem;
      }
    }
    
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
      font-weight: 600;
    }
    
    h2 {
      font-size: 1.4rem;
      margin-bottom: 1rem;
      color: #2E7D32;
    }
    
    /* --- Aufnahme-Controls --- */
    .record-controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    
    @media (min-width: 600px) {
      .record-controls {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      grid-column: 1 / -1;
    }
    
    .button-row {
      display: flex;
      gap: 0.5rem;
    }
    
    .button-row button {
      flex: 1;
    }
    
    .filename-input-container {
      position: relative;
      grid-column: 1 / -1;
    }
    
    input[type="text"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      transition: all 0.2s ease;
      -webkit-appearance: none;
      appearance: none;
    }
    
    input[type="text"]:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
    }
    
    .input-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #444;
    }
    
    /* --- Button Styles --- */
    button {
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      color: #fff;
      background: #4CAF50;
      transition: all 0.2s ease;
      -webkit-appearance: none;
      appearance: none;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 48px; /* F√ºr bessere Touch-Ziele auf iPads */
    }
    
    button:hover:not(:disabled) {
      background: #45a049;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0,0,0,0.1);
    }
    
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    
    button:disabled {
      background: #e0e0e0;
      color: #999;
      cursor: not-allowed;
    }
    
    button:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3);
    }
    
    /* --- Spezielle Button-Typen --- */
    #startBtn {
      background: #4CAF50;
    }
    
    #startBtn:hover:not(:disabled) {
      background: #3e9142;
    }
    
    #pauseBtn, #resumeBtn {
      background: #FF9800;
    }
    
    #pauseBtn:hover:not(:disabled), #resumeBtn:hover:not(:disabled) {
      background: #F57C00;
    }
    
    #stopBtn {
      background: #f44336;
    }
    
    #stopBtn:hover:not(:disabled) {
      background: #d32f2f;
    }
    
    #uploadBtn {
      background: #673AB7;
    }
    
    #uploadBtn:hover:not(:disabled) {
      background: #5E35B1;
    }
    
    /* --- Audio Format Anzeige --- */
    .format-info {
      background-color: #f1f8e9;
      border-radius: 8px;
      padding: 10px 15px;
      margin-bottom: 1.5rem;
      border-left: 4px solid #4CAF50;
    }
    
    /* --- Status-Anzeigen --- */
    .status-bar {
      display: flex;
      align-items: center;
      margin-bottom: 1rem;
      padding: 0.5rem 0;
      min-height: 2rem;
    }
    
    #timerDisplay {
      text-align: center;
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      color: #2E7D32;
    }
    
    /* --- Audio Player --- */
    audio {
      width: 100%;
      margin: 1.5rem 0;
      border-radius: 8px;
    }
    
    #uploadStatus {
      margin: 1rem 0;
      font-weight: 500;
      padding: 0.75rem;
      border-radius: 8px;
      background: #f5f5f5;
      min-height: 3rem;
      display: flex;
      align-items: center;
    }
    
    /* --- Visualizer --- */
    .visualizer-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 20px auto 40px auto;
      border: 2px solid #e0e0e0;
      border-radius: 50%;
      background: #fafafa;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
    }
    
    .visualizer-circle {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #f44336;
      border-radius: 50%;
      transition: width 0.1s, height 0.1s;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    }
    
    /* --- Tabs --- */
    .tab-container {
      margin-top: 2.5rem;
    }
    
    .tab-buttons {
      display: flex;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 1.5rem;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .tab-button {
      background: transparent;
      border: none;
      padding: 0.75rem 1.5rem;
      margin-right: 0.5rem;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      color: #666;
      font-weight: 500;
      min-width: auto;
    }
    
    .tab-button.active {
      background: #4CAF50;
      color: white;
    }
    
    .tab-content {
      display: none;
      padding: 1rem 0;
    }
    
    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* --- Dateien-Liste --- */
    .file-list, .admin-panel {
      margin-top: 2rem;
    }
    
    .file-list h2, .admin-panel h2 {
      margin-bottom: 1rem;
    }
    
    .file-list ul, .admin-panel ul {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }
    
    .file-list li, .admin-panel li {
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border-radius: 8px;
      background: #f8f9fa;
      transition: all 0.2s ease;
    }
    
    .file-list li:hover, .admin-panel li:hover {
      background: #f0f0f0;
    }
    
    .file-list a, .admin-panel a {
      color: #4CAF50;
      text-decoration: none;
      flex: 1;
      padding: 0.25rem 0;
    }
    
    .file-list a:hover, .admin-panel a:hover {
      text-decoration: underline;
    }
    
    /* --- Admin Panel --- */
    .admin-panel {
      display: none;
      border-top: 1px solid #e0e0e0;
      padding-top: 1.5rem;
      margin-top: 2rem;
    }
    
    .admin-panel button.delete {
      background: #f44336;
      padding: 0.5rem 0.75rem;
      margin-left: 0.75rem;
      font-size: 0.9rem;
    }
    
    .admin-panel button.delete:hover {
      background: #d32f2f;
    }
    
    #adminLoginBtn {
      background: #333;
      margin-top: 2rem;
    }
    
    #closeAdminBtn {
      background: #333;
    }
    
    /* --- Indikatoren und Animationen --- */
    .recording-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f44336;
      margin-right: 8px;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    
    .status-icon {
      margin-right: 5px;
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
      100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
    }
    
    .error-message {
      color: #f44336;
      font-weight: 500;
    }
    
    .success-message {
      color: #4CAF50;
      font-weight: 500;
    }
    
    /* Mikrofon-Zugriffswarnung */
    .microphone-warning {
      display: none;
      background-color: #fffde7;
      border: 1px solid #ffd600;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
    
    .microphone-warning h3 {
      margin-top: 0;
      color: #f57f17;
    }
    
    .microphone-warning ul {
      margin-bottom: 0;
    }
    
    /* iOS-spezifische Styles */
    .ios-note {
      background-color: #e3f2fd;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      border-left: 4px solid #2196F3;
    }
    
    /* Verbesserte iPad-spezifische Styles */
    @media (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2), 
           (max-width: 1024px) and (min-resolution: 192dpi) {
      button, input, select {
        font-size: 1.1rem;
        padding: 0.85rem 1rem;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .visualizer-container {
        width: 180px;
        height: 180px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Podcast Aufnahme ‚Äì Audio Recorder</h1>
  </header>

  <div class="container">
    <!-- Mikrofon-Zugriffswarnung f√ºr iOS -->
    <div class="microphone-warning" id="microphoneWarning">
      <h3>‚ö†Ô∏è Mikrofon-Zugriff erforderlich</h3>
      <p>Ihr Ger√§t erlaubt den Zugriff auf das Mikrofon nicht. So k√∂nnen Sie den Zugriff aktivieren:</p>
      <ul>
        <li>Stellen Sie sicher, dass Sie "Erlauben" dr√ºcken, wenn nach Mikrofonzugriff gefragt wird</li>
        <li>√úberpr√ºfen Sie die Einstellungen Ihres Browsers oder Ger√§ts, um den Mikrofonzugriff zu aktivieren</li>
        <li>Auf iOS: √ñffnen Sie die Einstellungen > Safari > Seitenberechtigung > Mikrofon und aktivieren Sie den Zugriff</li>
      </ul>
    </div>

    <!-- iOS-spezifischer Hinweis -->
    <div class="ios-note" id="iosNote">
      <h3>üì± Hinweis f√ºr iOS-Nutzer</h3>
      <p>Diese App verwendet automatisch ein mit Ihrem Ger√§t kompatibles Audioformat. Es ist m√∂glich, dass die Aufnahmequalit√§t auf iOS-Ger√§ten etwas geringer ist als auf Desktop-Browsern.</p>
    </div>

    <!-- Aufnahme-Steuerung -->
    <div class="filename-input-container">
      <label for="filename" class="input-label">Dateiname (Pflicht)</label>
      <input type="text" id="filename" placeholder="Bitte Dateinamen eingeben" />
    </div>

    <!-- Audio-Format Info (kein Dropdown mehr f√ºr iOS) -->
    <div class="format-info" id="formatInfo">
      Aktuelles Format: <span id="currentFormat">Wird ermittelt...</span>
    </div>

    <div class="button-group">
      <div class="button-row">
        <button id="startBtn">Aufnahme starten</button>
        <button id="stopBtn" disabled>Stoppen</button>
      </div>
      <div class="button-row">
        <button id="pauseBtn" disabled>Pausieren</button>
        <button id="resumeBtn" disabled>Fortsetzen</button>
      </div>
      <button id="uploadBtn" disabled>Hochladen</button>
    </div>

    <!-- Status-Anzeige -->
    <div class="status-bar">
      <span id="recordingStatus"></span>
    </div>

    <!-- Timer-Anzeige -->
    <div id="timerDisplay">00:00</div>

    <!-- Audio-Vorschau & Status -->
    <audio id="audioPlayer" controls></audio>
    <p id="uploadStatus"></p>

    <!-- Visueller Lautst√§rke-Indikator -->
    <div class="visualizer-container">
      <div class="visualizer-circle" id="visualizerCircle"></div>
    </div>

    <!-- Tab-Navigation -->
    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="recordings">Aufnahmen</button>
        <button class="tab-button" data-tab="help">Hilfe</button>
      </div>
      
      <!-- Aufnahmen Tab -->
      <div class="tab-content active" id="recordings-tab">
        <!-- √ñffentliche Dateiliste -->
        <div class="file-list">
          <h2>Vorhandene Aufnahmen</h2>
          <ul id="fileList"></ul>
        </div>
      </div>
      
      <!-- Hilfe Tab -->
      <div class="tab-content" id="help-tab">
        <h2>Verwendung</h2>
        <ol>
          <li>Geben Sie einen Dateinamen ein</li>
          <li>Klicken Sie auf "Aufnahme starten"</li>
          <li>Sie k√∂nnen die Aufnahme pausieren und fortsetzen</li>
          <li>Nach dem Stoppen k√∂nnen Sie die Aufnahme anh√∂ren</li>
          <li>Klicken Sie auf "Hochladen", um die Aufnahme zu speichern</li>
        </ol>
        <p><strong>Hinweis:</strong> Ihr Browser speichert die letzte Aufnahme lokal. Sie k√∂nnen die Seite neu laden, ohne die Aufnahme zu verlieren.</p>
        
        <h3>Fehlerbehebung</h3>
        <ul>
          <li><strong>Mikrofon funktioniert nicht:</strong> Pr√ºfen Sie die Browsereinstellungen und erteilen Sie die Berechtigung f√ºr den Mikrofonzugriff.</li>
          <li><strong>Aufnahme startet nicht:</strong> Stellen Sie sicher, dass ein Dateiname eingegeben wurde.</li>
          <li><strong>Probleme auf iOS:</strong> Starten Sie Safari neu oder verwenden Sie den Privatmodus, falls Sie Probleme haben.</li>
          <li><strong>Hochladen funktioniert nicht:</strong> M√∂glicherweise ist die Verbindung zum Server unterbrochen. Versuchen Sie es sp√§ter erneut.</li>
        </ul>
      </div>
    </div>

    <!-- Admin-Oberfl√§che -->
    <div class="admin-panel" id="adminPanel">
      <h2>Admin-Oberfl√§che</h2>
      <button id="downloadAllBtn">Alles herunterladen</button>
      <ul id="adminFileList"></ul>
      <button id="closeAdminBtn">Admin schlie√üen</button>
    </div>

    <!-- Admin-Login Button -->
    <button id="adminLoginBtn">Admin Login</button>
  </div>

  <!-- Supabase (ES-Modul) -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

    // --- 1) SUPABASE KONFIG --- 
    // Diese Werte m√ºssen korrekt gesetzt werden
    const SUPABASE_URL = "https://qzmzlrsfuepbkqwzbrir.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6bXpscnNmdWVwYmtxd3picmlyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE5NTkxMzAsImV4cCI6MjA1NzUzNTEzMH0.zLZDSfylloUxlxYPEpfO4VMAdf0cNpUzKH2T9qv8ezI";
    
    // Initialisiere Supabase Client
    let supabaseClient;
    try {
      supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      console.log("Supabase Client erfolgreich initialisiert");
    } catch (err) {
      console.error("Fehler bei der Supabase-Initialisierung:", err);
      showError("Verbindungsfehler: Bitte sp√§ter erneut versuchen.");
    }

    // --- 2) Variablen ---
    let mediaRecorder;
    let audioStream;
    let audioChunks = [];
    let currentRecordingBlob = null;
    let audioContext, analyser, dataArray, animationId;
    let recordingTime = 0;
    let recordingInterval = null;
    let isPaused = false;
    let isRecording = false;
    
    // Ger√§te- und Format-Erkennung
    const appSettings = {
      adminLoggedIn: false,
      lastFileName: localStorage.getItem('lastFileName') || '',
      isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && navigator.maxTouchPoints > 0,
      isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
      bestAudioFormat: 'audio/mp4' // Standard-Fallback f√ºr iOS
    };

    // --- 3) DOM-Elemente ---
    const filenameInput    = document.getElementById("filename");
    const startBtn         = document.getElementById("startBtn");
    const pauseBtn         = document.getElementById("pauseBtn");
    const resumeBtn        = document.getElementById("resumeBtn");
    const stopBtn          = document.getElementById("stopBtn");
    const uploadBtn        = document.getElementById("uploadBtn");
    const audioPlayer      = document.getElementById("audioPlayer");
    const uploadStatus     = document.getElementById("uploadStatus");
    const fileList         = document.getElementById("fileList");
    const adminPanel       = document.getElementById("adminPanel");
    const adminFileList    = document.getElementById("adminFileList");
    const adminLoginBtn    = document.getElementById("adminLoginBtn");
    const closeAdminBtn    = document.getElementById("closeAdminBtn");
    const visualizerCircle = document.getElementById("visualizerCircle");
    const downloadAllBtn   = document.getElementById("downloadAllBtn");
    const timerDisplay     = document.getElementById("timerDisplay");
    const recordingStatus  = document.getElementById("recordingStatus");
    const formatInfo       = document.getElementById("formatInfo");
    const currentFormat    = document.getElementById("currentFormat");
    const microphoneWarning = document.getElementById("microphoneWarning");
    const iosNote          = document.getElementById("iosNote");
    const tabButtons       = document.querySelectorAll(".tab-button");
    const tabContents      = document.querySelectorAll(".tab-content");

    // --- 4) Initialisierung ---
    async function init() {
      // Debug-Info f√ºr bessere Fehlerbehebung
      console.log("Browser-Info:", navigator.userAgent);
      console.log("Ger√§teerkennung - iOS:", appSettings.isIOS, "Safari:", appSettings.isSafari);
      
      // iOS-spezifische Anzeige
      if (appSettings.isIOS) {
        iosNote.style.display = "block";
      } else {
        iosNote.style.display = "none";
      }
      
      // Lade gespeicherte Einstellungen aus dem LocalStorage
      if (appSettings.lastFileName) {
        filenameInput.value = appSettings.lastFileName;
      }
      
      // Immer validateFileName ausf√ºhren, um den Button-Status zu aktualisieren
      validateFileName();
      
      // Pr√ºfe Browser-Unterst√ºtzung
      if (!checkBrowserSupport()) return;
      
      // Bestimme das beste Audio-Format f√ºr diesen Browser
      await determineOptimalAudioFormat();
      
      // Lade vorhandene Dateien mit Fehlerbehandlung
      loadFilesWithRetry();
      
      // Setze Event Listeners
      setupEventListeners();
      
      // Pr√ºfe, ob es eine gespeicherte Aufnahme gibt
      checkForSavedRecording();
    }

    // --- 5) Browser-Unterst√ºtzung pr√ºfen ---
    function checkBrowserSupport() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showError("Ihr Browser unterst√ºtzt keine Audioaufnahmen. Bitte verwenden Sie einen modernen Browser wie Chrome, Firefox oder Edge.");
        startBtn.disabled = true;
        return false;
      }
      return true;
    }
    
    // --- Neuer Schritt: Beste Audio-Format-Erkennung ---
    async function determineOptimalAudioFormat() {
      // F√ºr iOS-Ger√§te werden wir diese Formate in dieser Reihenfolge testen
      const formatsToTest = [
        'audio/mp4',
        'audio/aac',
        'audio/wav',
        'audio/mpeg',
        'audio/webm;codecs=pcm',
        'audio/webm'
      ];
      
      let foundFormat = false;
      
      // Standardwert anzeigen w√§hrend wir testen
      currentFormat.textContent = "Wird gepr√ºft...";
      
      for (const format of formatsToTest) {
        if (MediaRecorder.isTypeSupported(format)) {
          console.log(`Format ${format} wird unterst√ºtzt!`);
          appSettings.bestAudioFormat = format;
          currentFormat.textContent = formatReadableName(format);
          foundFormat = true;
          break;
        } else {
          console.log(`Format ${format} wird nicht unterst√ºtzt.`);
        }
      }
      
      if (!foundFormat) {
        // Wenn kein getestetes Format unterst√ºtzt wird, verwenden wir den Standard-MediaRecorder ohne expliziten mimeType
        currentFormat.textContent = "Standard (ger√§teabh√§ngig)";
        console.warn("Kein bekanntes Format wird unterst√ºtzt. Verwende Standard-Format des Browsers.");
        appSettings.bestAudioFormat = '';
      }
    }
    
    function formatReadableName(mimeType) {
      const formatMap = {
        'audio/mp4': 'MP4 Audio',
        'audio/aac': 'AAC Audio',
        'audio/wav': 'WAV Audio',
        'audio/mpeg': 'MP3 Audio',
        'audio/webm': 'WebM Audio',
        'audio/webm;codecs=pcm': 'WebM PCM Audio'
      };
      
      return formatMap[mimeType] || mimeType;
    }
    
    function getFileExtension(mimeType) {
      const extensionMap = {
        'audio/mp4': '.m4a',
        'audio/aac': '.aac',
        'audio/wav': '.wav',
        'audio/mpeg': '.mp3',
        'audio/webm': '.webm',
        'audio/webm;codecs=pcm': '.webm'
      };
      
      return extensionMap[mimeType] || '.m4a'; // Standardm√§√üig .m4a f√ºr iOS
    }

    // --- 6) Event Listeners ---
    function setupEventListeners() {
      // Dateiname-Validierung
      filenameInput.addEventListener("input", validateFileName);
      
      // Aufnahme-Steuerung
      startBtn.addEventListener("click", startRecording);
      pauseBtn.addEventListener("click", pauseRecording);
      resumeBtn.addEventListener("click", resumeRecording);
      stopBtn.addEventListener("click", stopRecording);
      uploadBtn.addEventListener("click", uploadRecording);
      
      // Admin-Bereich
      adminLoginBtn.addEventListener("click", handleAdminLogin);
      closeAdminBtn.addEventListener("click", () => {
        adminPanel.style.display = "none";
        appSettings.adminLoggedIn = false;
      });
      downloadAllBtn.addEventListener("click", downloadAllFiles);
      
      // Tab-Navigation
      tabButtons.forEach(button => {
        button.addEventListener("click", () => {
          const tabId = button.dataset.tab;
          
          // Aktiven Tab wechseln
          tabButtons.forEach(btn => btn.classList.remove("active"));
          tabContents.forEach(content => content.classList.remove("active"));
          
          button.classList.add("active");
          document.getElementById(`${tabId}-tab`).classList.add("active");
        });
      });

      // Dateiliste L√∂schen (nur f√ºr Admin)
      adminFileList.addEventListener("click", handleAdminFileAction);
      
      // F√ºr iOS Touch-Events aktivieren
      if (appSettings.isIOS) {
        document.addEventListener('touchstart', function(){}, {passive: true});
      }
    }

    // --- 7) Dateiname-Validierung ---
    function validateFileName() {
      const filename = filenameInput.value.trim();
      
      if (filename) {
        startBtn.disabled = false;
        localStorage.setItem('lastFileName', filename);
      } else {
        startBtn.disabled = true;
      }

      // Debug-Information
      console.log("Dateiname validiert:", filename, "Start-Button aktiviert:", !startBtn.disabled);
    }

    // --- 8) Aufnahme starten ---
    async function startRecording() {
      const filename = filenameInput.value.trim();
      
      if (!filename) {
        showError("Bitte erst einen Dateinamen eingeben!");
        return;
      }
      
      if (!checkBrowserSupport()) return;
      
      try {
        // Mikrofon-Warnung ausblenden
        microphoneWarning.style.display = "none";
        
        // Spezielle Constraints f√ºr iOS
        const constraints = {
          audio: true
        };
        
        if (appSettings.isIOS) {
          // iOS ben√∂tigt manchmal explizite Einstellungen
          constraints.audio = {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          };
        }
        
        // Audiostream anfordern mit besserer Fehlerbehandlung
        try {
          audioStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (micError) {
          console.error("Mikrofon-Zugriffsfehler:", micError);
          
          if (micError.name === 'NotAllowedError' || micError.name === 'PermissionDeniedError') {
            microphoneWarning.style.display = "block";
            throw new Error("Mikrofon-Zugriff verweigert. Bitte erteilen Sie die Berechtigung in Ihren Browsereinstellungen.");
          } else if (micError.name === 'NotFoundError') {
            throw new Error("Kein Mikrofon gefunden. Bitte pr√ºfen Sie, ob ein Mikrofon angeschlossen ist.");
          } else {
            throw micError;
          }
        }
        
        // MediaRecorder initialisieren
        let recorderOptions = {};
        
        // Verwende das beste erkannte Format, wenn verf√ºgbar
        if (appSettings.bestAudioFormat) {
          recorderOptions.mimeType = appSettings.bestAudioFormat;
          console.log(`Verwende Format: ${appSettings.bestAudioFormat}`);
        } else {
          console.log("Verwende Standard-Format des Browsers");
        }
        
        try {
          mediaRecorder = new MediaRecorder(audioStream, recorderOptions);
        } catch (formatError) {
          console.error("Format wird nicht unterst√ºtzt:", formatError);
          console.log("Versuche ohne mimeType-Angabe...");
          mediaRecorder = new MediaRecorder(audioStream);
          
          // Update formatInfo-Anzeige
          currentFormat.textContent = "Standard (ger√§teabh√§ngig)";
        }
        
        // MediaRecorder-Format anzeigen
        if (mediaRecorder.mimeType) {
          currentFormat.textContent = formatReadableName(mediaRecorder.mimeType);
          console.log("Tats√§chlich verwendetes Format:", mediaRecorder.mimeType);
          appSettings.bestAudioFormat = mediaRecorder.mimeType;
        }
        
        audioChunks = [];
        
        // Event Handling
        mediaRecorder.ondataavailable = handleDataAvailable;
        mediaRecorder.onstop = handleRecordingStop;
        mediaRecorder.onpause = handleRecordingPause;
        mediaRecorder.onresume = handleRecordingResume;
        mediaRecorder.onerror = (event) => {
          showError("Aufnahmefehler: " + event.error);
        };
        
        // Aufnahme starten
        mediaRecorder.start(100); // Chunks alle 100ms f√ºr bessere iOS-Kompatibilit√§t
        isRecording = true;
        isPaused = false;
        
        // UI aktualisieren
        updateRecordingUI(true);
        
        // Visualizer und Timer starten
        startVisualizer(audioStream);
        startTimer();
        
        showMessage("Aufnahme l√§uft...", true);
      } catch (err) {
        showError(err.message || "Aufnahmefehler. Bitte versuchen Sie es erneut.");
        console.error("Aufnahmefehler:", err);
        
        // Mikrofon-Warnung anzeigen
        microphoneWarning.style.display = "block";
      }
    }
    
    // --- 9) Aufnahme pausieren ---
    function pauseRecording() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        try {
          mediaRecorder.pause();
          isPaused = true;
          pauseTimer();
          pauseVisualizer();
          updateRecordingUI(true, true);
          showMessage("Aufnahme pausiert", false);
        } catch (error) {
          console.error("Fehler beim Pausieren:", error);
          // Wenn pausieren auf iOS fehlschl√§gt, bieten wir an, stattdessen zu stoppen
          if (appSettings.isIOS) {
            showWarning("Pausieren wird auf einigen iOS-Ger√§ten nicht unterst√ºtzt. Bitte stoppen Sie die Aufnahme, wenn Sie fertig sind.");
          }
        }
      }
    }
    
    // --- 10) Aufnahme fortsetzen ---
    function resumeRecording() {
      if (mediaRecorder && mediaRecorder.state === "paused") {
        try {
          mediaRecorder.resume();
          isPaused = false;
          resumeTimer();
          resumeVisualizer();
          updateRecordingUI(true, false);
          showMessage("Aufnahme fortgesetzt", true);
        } catch (error) {
          console.error("Fehler beim Fortsetzen:", error);
          showWarning("Es gab ein Problem beim Fortsetzen der Aufnahme. Versuchen Sie, die Aufnahme zu stoppen und neu zu starten.");
        }
      }
    }

    // --- 11) Aufnahme stoppen ---
    function stopRecording() {
      if (mediaRecorder && (mediaRecorder.state === "recording" || mediaRecorder.state === "paused")) {
        try {
          mediaRecorder.stop();
          isRecording = false;
          isPaused = false;
          
          if (audioStream) {
            audioStream.getTracks().forEach(track => track.stop());
          }
          
          stopTimer();
          stopVisualizer();
          updateRecordingUI(false);
        } catch (error) {
          console.error("Fehler beim Stoppen der Aufnahme:", error);
          showError("Fehler beim Stoppen der Aufnahme. Bitte laden Sie die Seite neu.");
          
          // Notfall-Reset falls das Stoppen nicht funktioniert
          isRecording = false;
          isPaused = false;
          stopTimer();
          stopVisualizer();
          updateRecordingUI(false);
          
          if (audioStream) {
            audioStream.getTracks().forEach(track => track.stop());
          }
        }
      }
    }

    // --- 12) Media Recorder Event Handler ---
    function handleDataAvailable(event) {
      if (event.data && event.data.size > 0) {
        audioChunks.push(event.data);
        // Speichere den aktuellen Stand im LocalStorage
        saveRecordingChunks();
      }
    }
    
    function handleRecordingStop() {
      try {
        // Erstelle Blob aus gesammelten Daten
        const mimeType = appSettings.bestAudioFormat || 'audio/mp4';
        currentRecordingBlob = new Blob(audioChunks, { type: mimeType });
        
        // Audio-Player aktualisieren
        const audioUrl = URL.createObjectURL(currentRecordingBlob);
        audioPlayer.src = audioUrl;
        
        // UI aktualisieren
        uploadBtn.disabled = false;
        showMessage("Aufnahme bereit ‚Äì bitte jetzt anh√∂ren und hochladen.", false);
        
        // Lokale Kopie speichern
        saveRecording(currentRecordingBlob, mimeType);
        
        console.log("Aufnahme erfolgreich gestoppt. Gr√∂√üe:", formatBytes(currentRecordingBlob.size), "Format:", mimeType);
      } catch (error) {
        console.error("Fehler beim Verarbeiten der Aufnahme:", error);
        showError("Fehler beim Verarbeiten der Aufnahme: " + error.message);
      }
    }
    
    function handleRecordingPause() {
      showMessage("Aufnahme pausiert", false);
    }
    
    function handleRecordingResume() {
      showMessage("Aufnahme fortgesetzt", true);
    }

    // --- 13) Aufnahme hochladen ---
    async function uploadRecording() {
      if (!currentRecordingBlob) {
        showError("Keine Aufnahme vorhanden!");
        return;
      }
      
      showMessage("Wird hochgeladen...", false);
      uploadBtn.disabled = true;
      
      // Dateinamen vorbereiten
      let baseName = filenameInput.value.trim();
      const mimeType = appSettings.bestAudioFormat || 'audio/mp4';
      let extension = getFileExtension(mimeType);
      
      // Dateinamen mit Endung erstellen
      const fileName = baseName + extension;
      
      try {
        console.log("Upload starten: Datei", fileName, "Gr√∂√üe:", formatBytes(currentRecordingBlob.size), "Format:", mimeType);
        
        // Auf Supabase hochladen mit Wiederholungslogik
        const uploadWithRetry = async (retries = 3) => {
          try {
            const { error } = await supabaseClient
              .storage
              .from('podcast-audio')
              .upload(fileName, currentRecordingBlob, { 
                contentType: mimeType,
                cacheControl: '3600'
              });
            
            if (error) {
              throw error;
            }
            
            return { success: true };
          } catch (error) {
            console.warn(`Upload-Versuch fehlgeschlagen (${retries} verbleibend):`, error);
            
            if (retries > 0) {
              await new Promise(resolve => setTimeout(resolve, 1000)); // 1s warten
              return uploadWithRetry(retries - 1);
            }
            
            throw error;
          }
        };
        
        await uploadWithRetry();
        
        // Erfolgsmeldung
        showSuccess("‚úÖ Erfolgreich hochgeladen: " + fileName);
        currentRecordingBlob = null;
        
        // Lokale Aufnahme l√∂schen
        clearSavedRecording();
        
        // Dateiliste aktualisieren
        loadFilesWithRetry();
      } catch (error) {
        console.error("Upload-Fehler:", error);
        showError("‚ùå Fehler beim Upload: " + (error.message || "Verbindungsproblem"));
        uploadBtn.disabled = false;
      }
    }

    // --- 14) √ñffentliche Dateiliste laden mit Wiederholungen ---
    async function loadFilesWithRetry(retries = 3) {
      if (retries <= 0) {
        fileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien nach mehreren Versuchen</li>";
        return;
      }
      
      fileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      try {
        console.log("Dateien werden geladen, Versuch", 4-retries);
        
        const { data, error } = await supabaseClient.storage
          .from('podcast-audio')
          .list('', { limit: 100, offset: 0, sortBy: { column: 'created_at', order: 'desc' } });
        
        if (error) {
          throw error;
        }
        
        fileList.innerHTML = "";
        
        if (!data || data.length === 0) {
          fileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
          return;
        }
        
        for (const file of data) {
          const { data: publicUrl } = supabaseClient
            .storage
            .from('podcast-audio')
            .getPublicUrl(file.name);
          
          const li = document.createElement('li');
          li.innerHTML = `
            <a href="${publicUrl.publicUrl}" target="_blank" download="${file.name}">
              ${file.name}
            </a>
            <span>(${formatBytes(file.metadata?.size || 0)})</span>
          `;
          fileList.appendChild(li);
        }
      } catch (err) {
        console.error("Fehler beim Laden der Dateien:", err);
        
        // Wiederhole nach kurzer Verz√∂gerung
        setTimeout(() => {
          loadFilesWithRetry(retries - 1);
        }, 1500);
      }
    }

    // --- 15) Admin-Bereich ---
    function handleAdminLogin() {
      // WARNUNG: In Produktion sollte das Passwort nicht im Client-Code sein
      // Besser: Server-seitige Authentifizierung
      const storedHash = localStorage.getItem('adminHash');
      
      if (storedHash) {
        // Hash aus LocalStorage verwenden (Nutzer bereits angemeldet)
        const pwd = prompt("Bitte Admin-Passwort eingeben:");
        
        if (pwd && hashPassword(pwd) === storedHash) {
          showAdminPanel();
        } else {
          alert("Falsches Passwort!");
        }
      } else {
        // Neues Passwort speichern (Demo-Zwecke)
        const pwd = prompt("Bitte Admin-Passwort eingeben:");
        
        if (pwd === "Luna") {
          // Passwort hashen und im LocalStorage speichern
          localStorage.setItem('adminHash', hashPassword(pwd));
          showAdminPanel();
        } else {
          alert("Falsches Passwort!");
        }
      }
    }
    
    function showAdminPanel() {
      adminPanel.style.display = "block";
      appSettings.adminLoggedIn = true;
      loadAdminFilesWithRetry();
    }
    
    // Einfache Hash-Funktion (nur f√ºr Demo, nicht sicher!)
    function hashPassword(password) {
      let hash = 0;
      for (let i = 0; i < password.length; i++) {
        hash = ((hash << 5) - hash) + password.charCodeAt(i);
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash.toString(16);
    }

    // --- 16) Admin-Dateien laden ---
    async function loadAdminFilesWithRetry(retries = 3) {
      if (retries <= 0) {
        adminFileList.innerHTML = "<li class='error-message'>Fehler beim Laden der Dateien nach mehreren Versuchen</li>";
        return;
      }
      
      adminFileList.innerHTML = "<li>Dateien werden geladen...</li>";
      
      try {
        console.log("Admin-Dateien werden geladen, Versuch", 4-retries);
        
        const { data, error } = await supabaseClient.storage
          .from('podcast-audio')
          .list('', { limit: 100, offset: 0, sortBy: { column: 'created_at', order: 'desc' } });
        
        if (error) {
          throw error;
        }
        
        adminFileList.innerHTML = "";
        
        if (!data || data.length === 0) {
          adminFileList.innerHTML = "<li>Keine Aufnahmen vorhanden</li>";
          return;
        }
        
        for (const file of data) {
          const { data: publicUrl } = supabaseClient
            .storage
            .from('podcast-audio')
            .getPublicUrl(file.name);
          
          const li = document.createElement('li');
          li.innerHTML = `
            <a href="${publicUrl.publicUrl}" target="_blank">${file.name}</a>
            <span>(${formatBytes(file.metadata?.size || 0)})</span>
            <button class="delete" data-filename="${file.name}">L√∂schen</button>
          `;
          adminFileList.appendChild(li);
        }
      } catch (err) {
        console.error("Fehler beim Laden der Admin-Dateien:", err);
        
        // Wiederhole nach kurzer Verz√∂gerung
        setTimeout(() => {
          loadAdminFilesWithRetry(retries - 1);
        }, 1500);
      }
    }

    // --- 17) Admin-Dateiaktionen ---
    async function handleAdminFileAction(e) {
      if (!e.target.classList.contains("delete")) return;
      
      const fileName = e.target.getAttribute("data-filename");
      
      if (!confirm(`Sind Sie sicher, dass Sie die Datei "${fileName}" l√∂schen m√∂chten?`)) {
        return;
      }
      
      try {
        const { error } = await supabaseClient
          .storage
          .from('podcast-audio')
          .remove([fileName]);
          
        if (error) {
          throw error;
        }
        
        showSuccess(`Datei '${fileName}' wurde gel√∂scht.`);
        loadFilesWithRetry();
        loadAdminFilesWithRetry();
      } catch (err) {
        showError("Fehler beim L√∂schen: " + err.message);
      }
    }

    // --- 18) Alles herunterladen (ZIP) ---
    async function downloadAllFiles() {
      showMessage("ZIP-Datei wird vorbereitet...", false);
      
      try {
        // Alle Dateien abrufen
        const { data, error } = await supabaseClient.storage
          .from('podcast-audio')
          .list('', { limit: 100, offset: 0, sortBy: { column: 'name', order: 'asc' } });
        
        if (error) {
          throw error;
        }
        
        if (!data || data.length === 0) {
          showWarning("Keine Dateien zum Herunterladen vorhanden.");
          return;
        }
        
        // ZIP-Datei erstellen
        const zip = new JSZip();
        let completedDownloads = 0;
        let failedDownloads = 0;
        
        // Fortschritt anzeigen
        showMessage(`Lade 0/${data.length} Dateien...`, false);
        
        // Alle Dateien herunterladen und zum ZIP hinzuf√ºgen
        for (const file of data) {
          const fileName = file.name;
          const { data: publicUrlData } = supabaseClient
            .storage
            .from('podcast-audio')
            .getPublicUrl(fileName);
            
          const fileUrl = publicUrlData.publicUrl;
          
          try {
            // Mit Wiederholungsversuchen
            let response = null;
            let attempts = 0;
            
            while (!response && attempts < 3) {
              try {
                response = await fetch(fileUrl);
                if (!response.ok) throw new Error(`HTTP Fehler: ${response.status}`);
              } catch (fetchError) {
                attempts++;
                if (attempts >= 3) throw fetchError;
                await new Promise(resolve => setTimeout(resolve, 1000)); // 1s warten
              }
            }
            
            const blob = await response.blob();
            zip.file(fileName, blob);
            
            completedDownloads++;
            showMessage(`Lade ${completedDownloads}/${data.length} Dateien...`, false);
          } catch (fetchError) {
            console.error(`Fehler beim Laden von ${fileName}:`, fetchError);
            failedDownloads++;
            // Fehler f√ºr einzelne Dateien ignorieren, aber loggen
          }
        }
        
        // ZIP erstellen und herunterladen
        showMessage("ZIP-Datei wird erstellt...", false);
        const content = await zip.generateAsync({ type: "blob" });
        
        // Aktuelles Datum f√ºr Dateinamen
        const date = new Date();
        const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        
        saveAs(content, `podcast-aufnahmen-${dateStr}.zip`);
        
        if (failedDownloads > 0) {
          showWarning(`ZIP-Datei erstellt mit ${completedDownloads} Dateien. ${failedDownloads} Dateien konnten nicht geladen werden.`);
        } else {
          showSuccess("ZIP-Datei wurde erstellt und heruntergeladen.");
        }
      } catch (err) {
        showError("Fehler beim ZIP-Erstellen: " + err.message);
      }
    }

    // --- 19) Visualizer Funktionen ---
    function startVisualizer(stream) {
      try {
        // AudioContext erstellen
        audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        // Visualizer starten
        animateVisualizer();
      } catch (error) {
        console.warn("Visualizer konnte nicht initialisiert werden:", error);
        // Wir brechen die Aufnahme nicht ab, nur weil der Visualizer nicht funktioniert
      }
    }
    
    function animateVisualizer() {
      if (!analyser) return;
      
      try {
        animationId = requestAnimationFrame(animateVisualizer);
        analyser.getByteTimeDomainData(dataArray);
        
        // RMS (Root Mean Square) Berechnung f√ºr Lautst√§rke
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          const val = dataArray[i] - 128;
          sum += val * val;
        }
        
        const rms = Math.sqrt(sum / dataArray.length);
        const size = 40 + rms; // Basisgr√∂√üe + Lautst√§rke
        
        // Kreisgr√∂√üe aktualisieren
        visualizerCircle.style.width = size + "px";
        visualizerCircle.style.height = size + "px";
      } catch (error) {
        console.warn("Visualizer-Fehler:", error);
        cancelAnimationFrame(animationId);
      }
    }
    
    function pauseVisualizer() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }
    
    function resumeVisualizer() {
      if (audioContext && analyser) {
        animateVisualizer();
      }
    }
    
    function stopVisualizer() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      if (audioContext) {
        try {
          audioContext.close();
        } catch (e) {
          console.warn("Fehler beim Schlie√üen des AudioContext:", e);
        }
        audioContext = null;
      }
      
      // Kreisgr√∂√üe zur√ºcksetzen
      visualizerCircle.style.width = "40px";
      visualizerCircle.style.height = "40px";
    }

    // --- 20) Timer Funktionen ---
    function startTimer() {
      recordingTime = 0;
      updateTimerDisplay(0);
      recordingInterval = setInterval(() => {
        recordingTime++;
        updateTimerDisplay(recordingTime);
      }, 1000);
    }
    
    function pauseTimer() {
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }
    
    function resumeTimer() {
      if (!recordingInterval) {
        recordingInterval = setInterval(() => {
          recordingTime++;
          updateTimerDisplay(recordingTime);
        }, 1000);
      }
    }
    
    function stopTimer() {
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }
    
    function updateTimerDisplay(seconds) {
      const mm = String(Math.floor(seconds / 60)).padStart(2, "0");
      const ss = String(seconds % 60).padStart(2, "0");
      timerDisplay.textContent = `${mm}:${ss}`;
    }

    // --- 21) UI-Hilfsfunktionen ---
    function updateRecordingUI(isActive, isPaused = false) {
      // Aufnahme aktiv
      if (isActive) {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        // Pause-Status
        if (isPaused) {
          pauseBtn.disabled = true;
          resumeBtn.disabled = false;
          recordingStatus.innerHTML = '<span class="status-icon">‚è∏Ô∏è</span> Aufnahme pausiert';
        } else {
          pauseBtn.disabled = false;
          resumeBtn.disabled = true;
          recordingStatus.innerHTML = '<span class="recording-indicator"></span> Aufnahme l√§uft';
        }
      } 
      // Aufnahme inaktiv
      else {
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;
        recordingStatus.innerHTML = '';
      }
      
      // Immer dateiname pr√ºfen
      validateFileName();
    }
    
    function showMessage(message, isRecording = false) {
      if (isRecording) {
        uploadStatus.innerHTML = `<span class="recording-indicator"></span> ${message}`;
      } else {
        uploadStatus.textContent = message;
      }
    }
    
    function showError(message) {
      uploadStatus.innerHTML = `<span class="error-message">‚ùå ${message}</span>`;
      console.error(message);
    }
    
    function showWarning(message) {
      uploadStatus.innerHTML = `<span style="color: #FF9800;">‚ö†Ô∏è ${message}</span>`;
      console.warn(message);
    }
    
    function showSuccess(message) {
      uploadStatus.innerHTML = `<span class="success-message">${message}</span>`;
    }
    
    // --- 22) Lokale Speicherung ---
    function saveRecording(blob, mimeType) {
      try {
        // In IndexedDB speichern (vereinfacht mit localStorage)
        localStorage.setItem('lastRecordingMimeType', mimeType);
        
        // Blob als Base64 speichern
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          const base64data = reader.result;
          localStorage.setItem('lastRecordingData', base64data);
        };
      } catch (err) {
        console.warn("Konnte Aufnahme nicht lokal speichern:", err);
      }
    }
    
    // Speichert aktuelle Audiochunks (f√ºr Wiederherstellung)
    function saveRecordingChunks() {
      // Wir speichern hier nicht die Chunks selbst, da das zu viel w√§re
      // Stattdessen markieren wir, dass eine Aufnahme l√§uft
      if (isRecording) {
        localStorage.setItem('recordingInProgress', 'true');
      }
    }
    
    function clearSavedRecording() {
      localStorage.removeItem('lastRecordingData');
      localStorage.removeItem('lastRecordingMimeType');
      localStorage.removeItem('recordingInProgress');
    }
    
    function checkForSavedRecording() {
      const savedRecording = localStorage.getItem('lastRecordingData');
      const savedMimeType = localStorage.getItem('lastRecordingMimeType');
      
      if (savedRecording && savedMimeType) {
        // Vorherige Aufnahme wiederherstellen
        try {
          // Base64 in Blob umwandeln
          const byteString = atob(savedRecording.split(',')[1]);
          const ab = new ArrayBuffer(byteString.length);
          const ia = new Uint8Array(ab);
          
          for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
          }
          
          currentRecordingBlob = new Blob([ab], { type: savedMimeType });
          const audioUrl = URL.createObjectURL(currentRecordingBlob);
          audioPlayer.src = audioUrl;
          
          // UI aktualisieren
          uploadBtn.disabled = false;
          showMessage("Gespeicherte Aufnahme geladen. Sie k√∂nnen sie hochladen oder eine neue erstellen.");
        } catch (err) {
          console.warn("Fehler beim Laden der gespeicherten Aufnahme:", err);
          clearSavedRecording();
        }
      }
      
      // Pr√ºfe, ob eine Aufnahme unterbrochen wurde
      const inProgress = localStorage.getItem('recordingInProgress');
      if (inProgress === 'true') {
        showWarning("Eine fr√ºhere Aufnahme wurde unterbrochen. Bitte starten Sie eine neue Aufnahme.");
        localStorage.removeItem('recordingInProgress');
      }
    }
    
    // --- 23) Hilfsfunktionen ---
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';
      
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    
    // --- 24) Initialisierung starten ---
    init();
  </script>
</body>
</html>